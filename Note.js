Урок 1 Переменные
Для создания коробки(переменной)в которой будет хранится записка(значение) пишем: let number=10
Для создания имени переменной есть всего 2 правила: 1. имя может содержать буквы, цифры или сиволы "$","_"
                                                    2.  цифра не может стоять первой
Переменные с именами APPLE и apple -это разные переменные  
Существует список имён, которые нельзя использовать в качесте имени переменной: let, 
class, return и function
Можно создатьпеременную просто присвоив ей значениебез слова "let", если мы НЕ напишем перед этим 
команду в кавычках"use strict", в противном случае выдаст  ошибку  сообщающую нам о  том что переменная 
не найдена

Константы
в отличие от переменных константам не возможно поменять присвоенное значение
в место let пишем const
Если мы с самого начала знаем значание константы,  то имя пишем заглавными буквами, если значение 
константы узнаётся в середине кода, тогда пишем имя маленькими буквами

Необходимо научится задавать правельные  и  понятные имена, что бы было понятно сразу , что в себе 
содержит переменная 
Лучше создать больше переменных, чем использовать одну для всего, она  как коробка наполненная хаусом и 
нужно подойти и посмотреть, что б понять что в ней

Урок 2 Типы данных
Значения в JavaScript всегда относяться к какому-то типу данных, например к строке или числу
Кроме обычных чисел ещё существуют "специальные числовые значения", которые относятся к такому 
типу данных: Infinity, -Infinity, NaN
Infiniti (то есть бесконечноть  можно  получить в результате деления на  ноль)
NaN(означает вычислительную ошибку) его можно использоввать как математический термен, если хоть где-то 
в математических выражениях есть NaN, то и результатом будет NaN,  исключение  только NaN**0=1

BigInt
В JavaScript тип number не может безопасно работать с  чилами больше  чем 2^53-1 и меньше чем-(2^53-1)
В основном этогодиапазона для  работы достаточно, но есть случаи когда нам нужно работать с числами больше
 этого диапазона, тогда мы используем тип BigInt
Чтобы создать тип BigInt, добавляем букву  n после значения: let bigInt=87359667584576736457n

Строка(string)
Строка должна быть обязательно в кавычках, естьвсего 3 типа ковычек: '',"", и ``.
между  1 и 2 разницы нет, а вот 3 `перевёрнутые ковычки` имеют дополнительную функцию,а именно встраивать
 выражения в строку с помощью ${...}
Например: let name='Иван';console.log( `Привет, ${name}!`)\\выйдет Привет, Иван!
          ( `результат: ${1 + 2}` )\\результат: 3

Булевый тип
Может приниматьтолько 2 значения true или false. Этот тип как правило используется для хранения значений 
да/нет или как результат сравнений

Значение 'null'
Это специальное значение для пустоты, ничего

Значение 'undefinded'
Это означает, что не было присвоенно значение, и из-за этого не было найдено в коде

Объекты и символы
Тип object. В объектах хранятся колекции данных и более сложные структуры, чем в примитивных типах данных,
которые хранят в себе только строки и числа
А тип symbol используется для создания  уникальных идентификаторов в объектах

Оператор typeof
Этот  оператор возвращает  тип аргумента, к примеру typeof 0 // "number", typeof true // "boolean"
let people  = "pidr";
if (typeof (people) === 'number'){
    console.log(true)
}
else{
    console.log(false)
}

Урок 3
Преобразование  типов
Есть 3 типа: строковаое, численое и логическое
строковое преобразование - происходит когда требуется представление чего-либо ввиде строки, например 
console.log(value), так же мы можем использовать String(value)
let value = true
console.log(typeof value)//boolean

value = string(value)
console.log(typeof value)//string

Численое преобразование - происходит в математических функциях и выражениях, например когда операция
 деления (/) применяется не к числу console.log("6" / "2")//3, строки преобразуются в числа
Мы можем испозьзовать Number(value), чтобы явно преобразить  value к числу. Если с помощью   Number  
преобразовать True будет равен  1, а False=0,null=0
let str = "123"
console.log(typeof str)//string

let num = Number(str)// str долженбыть равен только числам, если будут буквы то выдаст NaN
console.log(typeof num)// number

Логическое преобразование -  выполнено с помощью функции boolean, пустые значения (0,  пустая  строка, 
    null, undefinded, NaN)=  False все остальные  =True
console.log(Boolean(1))//true
console.log(Boolean(0))//false

console.log(Boolean"Privet!")//true
console.log(Boolean"")//false

Урок 4
Базовые операторы,математика
Базовые операторы +-*/
Термены "унарный" "бинарный" "операнд". Операнд - это то к чему применяется оператор 5*2 левый операнд 
равен 5  и правый операнд равен 2
Унарным назвается оператор, который применяется к одному операдну
let x=1
x=-x
console.log(x)//-1

Бинарным называется оператор который применяется к двум операндам
let  x=1, y=3
console.log(y-x)//2

Поддерживаются следуйщие математические значения:  +-*/ %(взятие остатка деления)  ** (возыедение в степень) 
x** 1/2 (квадратный корень из х)
С помощью +  можно объеденить строки, и если хоть один операнд является строкой, то второй  так же 
превратится в строку, например console.log(1+'2');//12
Сложение и преобразование строк - это особенностьбинарного плюса, другие. Другие арифметические операторы 
работают только с числами и всегда  преобразуют операнды  в  числа console.log(6-"2");//4 
Плюс есть бинарный и унарный, выше я использовала бинарный. Унарный, то есть используется только к одному
 операнду, числа он никак не меняет, но если операнд не число,то унарный плюс его преобразит в число 
 console.log(+true);//1; console.log(+"");//0
let apples = "2"; let oranges="3"; console.log(+apples+ +oranges);//5, если написать просто apples+oranges, 
то сложаться строки и выдаст 23

Приоритеты операторов: 1. унарный  плюс и унарный минус, 2.возведение в степень, 3.умножение,деление, 
4.сложение, вычитание, 5.присваивание
Есть сокращённая арифметика с присваиванием, что бы не писать let n=10; n=n*2;, лучше  будет сократить и 
написать let n=10; n*=2; Подобные краткие формы записи существуют для всех арифметических и побитовых 
операторов

Одной из более частых числовых операций является увеличение или уменьшенее на 1, для этого существуют даже 
отдельные  операторы Инкремент++ и Декремент--
Инкремент и Декремент можно использовать только к переменной, ++5 выдаст ошибку, let counter=2; ++counter;
 console.log(counter);//3 еще ++ перед переменной означает что +1  будет в следйщем вызове, а ++ после
  сразу выдаст +1
Побитовые операторы: AND - и(&); OR - или (|); XOR - побитовое исключающее или(^); NOT - не (~); LEFT SHIFT - 
левый сдвиг(<<);RIGHT SHIFT - правый сдвиг (>>);ZERO-FILL RIGHTSHIFT- правый сдвиг с заполнениями нуля(>>>)
Оператор запятая: Используем запятую для разделения выражений, при этом будет выполнятся только последнее 
let a=(1+2,3+4);/7

Урок 5 Операторы сравнения
Как и в математике для сравзнения есть знаки больше(>) меньше(<) и равно(==), для сравнения используются 
именно 2 знака равно,один знак равно означает присваивание, для знака меньше/больше или равноиспользуем 
сочетание >=,<= и не равно !=. Все операторы после сравнения возращают или true или false. 
Так же можно сравнивать между собой не только  числа, но и строки,для этого JavaScript использует
алфавитный порядок Я>A//true, но строчные буквы не равны заглавным, JavaScript  считает что заглавная 
буква меньше чем строчная, поэтому А<а = true
Сравнение разных типов, при  сравнение разных типов JS  приводит каждое из них к  числу, '2'==2//true, 
само значение true=1,a false=0
Строгое сравнение. == - можетвызвать проблемы,ведь он не видит разници между 0,false и '', тогда используем
 ===, оно сравнивает без преобразование в один тип, так же есть оператор строгого неравенства !==
Сравнение с null и undefined. При использовании математических тепренов значения null/undefined 
преобразуются к  числам, null становится 0, а undefined - NaN

Урок 6 Условноеветвление if, '?'
Инструкция if(...) вычисляет условие  в скобкахи если результат true то выполняет код. 
If(...){console.log(...);}
Число 0, пуста строка '' , Null, undefined  и  NaN становятся False
Остальные значения становаятся True
Инструкция может содержать необязательный блок else(иначе), он выпоняется когда условие ложно. 
Иногда нужно проверить несколько  вариантов, для этого  используется блок else if
Оператор  "?"
let result  = условие  ? значение1 : значение2; Сначала вычисляется условие,если оно  
правдиво возвращается значени1,  если нет то значение2
 Иногда оператор "? " используется вместо If

 Урок 7 Логические операторы
 ||(или) &&(и) !(не) ??(оператор нулевого слияния)
 || - возвращает true если хоть один из аргументов true, true||true=true; 
 false||true=true;false||false=false - это традиционная логика
 так же есть расширенный алгоритм использования  оператора 'или', например result = value1||value2||value3;  
 выпоняются следуйщие действия 1. Вычисляются операнды слева направо 2. Каждый операнд конвертирует 
 логическое значение. Если результат true, возвращает исходное значение этого операнда 
 3. Если все операнды ложные, то  возвращает последний из них
 (1||0); 1;   (true||'no matter what');true; (null||1);1; (null||0||1);1   (undefined||null||0);0

&&- 'и' возвращает true только если оба  операнда true, иначе false
result=value1&&value2&&value3;1.слева направо 2.Если результат false останавливается и выводит 
исходное значение этогооперанда 3.  Если все true то выводит последнее истенное значение
приоритет оператора && больше чем ||   как если бы выпонялось (a&&b)||(c&&d), а оператор "не" 
имеет более высщую категорию и будет выполнятся первее "и"  или "или"

!-оператор 'не' result=!value; 1.приводит к логическому аргументу true/false 
2. меняет на противоположенное 
!!- двойной оператор "не" используют для преобразования к логическому типу

урок 8
Оператор нулевого слияния (??)
Он обрабатывает  null и  undefinded одинаковым образом
a ?? b = результат будет: если а оперделенно, то a, если нет, то b
resul=a??b  тоже самое что и result=(a!==null &&a!==undefined)? a:b
оператор "или" || может быть использован для того же что и ??, отличие между ними только
 в том что ||-возвращает первое истиное значение,а ??-возвращает первое определенное значение
приоритет ??  такой же как и || равен 3 в таблице на MND, это означает что ?? выполняется после = и ? 
но до таких операций как +*/
чтобы использовать в одном выражении и ?? и && или ||  то нужно использовать скобки иначе выдаст 
ошибку let x=(1&&2)??3;

урок 9
Циклы while и for
while(condition){
    //код
    //так же называемый: телом цикла
}
код из тела цикла выполняется пока condition is true 

Любое выражение или переменная может быть условием цикла,  например  while (i) тоже что и while (i!=0)

цикл do...while
do{
    //тело цикла
} while(condition);     
цикл сначало выполнит тело а затем проверит условие condition и пока его значение равно true 
он будет выполнятся снова и снова 

цикл for
for(начало; условие;шаг){
    //тело  цикла
}

Прерывание цикла break
обычно цикл заканчивается, когда условие равняется false, но мы может прервать  цикл раньше с помощью 
директивы break if(x===0)break;

Переход к следуйщей итерации: continue
Директива continue облегчённая версия break,при её выполнении цикл не прерывается а переходит к следуйщей 
итерации

урок 10
Конструкция switch заменяет собой сразу несколько if, она представляет собой наглядный пример 
сравнивать  выражения сразу с несколькими вариантами. Конструкция switch имеет один или более блок case
и необязательный блок default.

switch(x){
    case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
.переменная x проверяется на строгое равенство сначала со значением value1  потом с value2 и т.д
.Если соответствие установленно -  switch  начинает начинает выполнятся от соответствующей директивы
 case  и далее до ближайшего break(или до конца switch)
.Если ни один case не совпал,  то выполняется,  если есть, вариант default

Групировка case : можно  групировать несколько вариантов case 
case 3: // (*) группируем оба case
case 5:
    console.log('Неправильно!');
    console.log("Может вам посетить урок математики?");
    break; //3  и  5 теперь выводят одно и тоже  сообщение

Тип имеет значение!!
Проверка на равенствовсегда строгая и значения должны быть одного типа, что бы выполнялось равенство

let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    console.log( 'Один или ноль' );
    break;

  case '2':
    console.log( 'Два' );
    break;

  case 3:
    console.log( 'Никогда не выполнится!' );
    break;
  default:
    console.log( 'Неизвестное значение' );
}

Для '0' и '1' выполнится первый console.log.
Для '2' – второй console.log.
Но для 3, результат выполнения prompt будет строка "3", которая не соответствует строгому равенству ===
с числом 3. Таким образом, мы имеем «мёртвый код» в case 3! Выполнится вариант default.

Урок 11
функции
функции созданы для того чтобы не вызывать по несколько раз один и тот же код во многих местах. Функция -
это "основные строительные" блоки программы, например console.log() это функция

Объявление функции
для создания функции мы можем использовать объявление функции, выглядит это так:
function showMessage() {
    console.log( 'Всем привет!' );
  }
Наша новая функция может быть вызвана с помощью своего имени showMessage()
function showMessage() {
    console.log( 'Всем привет!' );
  }
  
  showMessage();
  showMessage();
Здесь мы увидим сообщение дважды

Локальные переменные
Переменные объявленные внутри  функции видны только внутри этой функции
function showMessage() {
    let message = "Привет, я JavaScript!"; // локальная переменная
  
    console.log( message );
  }
  
  showMessage(); // Привет, я JavaScript!
  
  console.log( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции

Внещние переменные
У функции есть доступ к внешним переменным
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  console.log(message);
}

showMessage(); // Привет, Вася

Функция обладает полным доступом к  внешним переменным и  может изменять их значение
let userName = 'Вася';

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + userName;
  console.log(message);
}

console.log( userName ); // Вася перед вызовом функции

showMessage();

console.log( userName ); // Петя, значение внешней переменной было изменено функцией

Внешняя переменная используется только если нет локальной
А если будет однаимённая внешняя переменная и внутренняя,  внутрення перекроет внешнюю
let userName = 'Вася';

function showMessage() {
  let userName = "Петя"; // объявляем локальную переменную

  let message = 'Привет, ' + userName; // Петя
  console.log(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

console.log( userName ); // Вася, не изменилась, функция не трогала внешнюю переменную


Параметры
с помощью параметров мы можем передать внутрь функции любую информацию
ниже я использую параметри from и Text

function showMessage(from, text) { // параметры: from, text
    console.log(from + ': ' + text);
  }
  
  showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
  showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)

Когда функция вызывается в строках (*) и (**), переданные значения копируются в локальные переменные from 
и text. Затем они используются в теле функции.

Вот ещё один пример: у нас есть переменная from, и мы передаём её функции. Обратите внимание: 
функция изменяет значение from, но это изменение не видно снаружи. Функция всегда получает только копию 
значения:
function showMessage(from, text) {

    from = '*' + from + '*'; // немного украсим "from"
  
    console.log( from + ': ' + text );
  }
  
  let from = "Аня";
  
  showMessage(from, "Привет"); // *Аня*: Привет
  
  // значение "from" осталось прежним, функция изменила значение локальной переменной
  console.log( from ); // Аня

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

Рассматривая приведённый выше пример, мы могли бы сказать: 
"функция showMessage объявляется с двумя параметрами, затем вызывается с двумя аргументами: 
from и "Привет""

Значения по умолчанию
Если при вызову функции аргумент не был указан, то его значением становится undefined
Например, вышеупомянутая функция showMessage(from, text) может быть вызвана с одним аргументом:

showMessage("Аня");
Это не приведёт к ошибке. Такой вызов выведет "*Аня*: undefined". В вызове не указан параметр text, 
поэтому предполагается, что text === undefined.

Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =:

function showMessage(from, text = "текст не добавлен") {
  console.log( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен
Теперь, если параметр text не указан, его значением будет "текст не добавлен"


в случае, если большинство ложных значений, таких как 0, следует расценивать как «нормальные».

function showCount(count) {
    // если count равен undefined или null, показать "неизвестно"
    console.log(count ?? "неизвестно");
  }
  showCount(0); // 0
  showCount(null); // неизвестно
  showCount(); // неизвестно

Возврат значения
function sum(a, b) {
    return a + b;
  }
  
  let result = sum(1, 2);
  console.log( result ); // 3

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого 
места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной 
result выше).

Вызовов return может быть несколько, например:
function checkAge(age) {
    if (age >= 18) {
      return true;
    } else {
      return confirm('А родители разрешили?');
    }
  }
  
  let age = prompt('Сколько вам лет?', 18);
  
  if ( checkAge(age) ) {
    console.log( 'Доступ получен' );
  } else {
    console.log( 'Доступ закрыт' );
  }


Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке,
что и return. Или, хотя бы, поставить там открывающую скобку, вот так:

return (
 some + long + expression
 + or +
 whatever * f(a) + f(b)
  ) 


Выбор имени функции
Функция – это действие. Поэтому имя функции обычно является глаголом. 
Оно должно быть кратким, точным и описывать действие функции

Функции, начинающиеся с…

"get…" – возвращают значение,
"calc…" – что-то вычисляют,
"create…" – что-то создают,
"check…" – что-то проверяют и возвращают логическое значение, и т.д.
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false

Функции==Коментарии
Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл 
разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо 
хорошее правило.

Урок 12
Function  Expression
Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).

Данный синтаксис позволяет нам создавать новую функцию в середине любого выражения.

Это выглядит следующим образом:

let sayHi = function() {
  console.log( "Привет" );
};
Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от =),
 это Function Expression.

Обратите внимание, что после ключевого слова function нет имени. Для Function Expression допускается 
его отсутствие.

Здесь мы сразу присваиваем её переменной, так что смысл этих примеров кода один и тот же: 
"создать функцию и поместить её в переменную sayHi".


Мы можем скопировать функцию в другую переменную:

function sayHi() {   // (1) создаём
  console.log( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет    //     эта тоже все ещё работает (почему бы и нет)
Давайте подробно разберём всё, что тут произошло:

Объявление Function Declaration (1) создаёт функцию и помещает её в переменную с именем sayHi.
В строке (2) мы скопировали её значение в переменную func. Обратите внимание (ещё раз): нет круглых скобок 
после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() 
в переменную func, а не саму функцию sayHi.
Теперь функция может вызываться как sayHi(), так и func().

Урок 13
Стрелочные функции
Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, 
чем Function Expression.

let func = (arg1, arg2, ...argN) => expression;

Давайте рассмотрим конкретный пример:

let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

console.log( sum(1, 2) ); // 3

Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:

let double = n => n * 2;
// примерно тоже что и: let double = function(n) { return n * 2 }

console.log( double(3) ); // 6

Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:

let sayHi = () => console.log("Hello!");

sayHi();


Иногда нам нужна более сложная функция, с несколькими выражениями и инструкциями.Это также возможно, нужно лишь заключить их в фигурные скобки. При этом важное отличие – в том, что в таких скобках для возврата значения нужно использовать return (как в обычных функциях).

Вроде этого:

let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

console.log( sum(1, 2) ); // 3

Урок 14
Основы JavaScript 
Чтобы по максимуму использовать возможности современного JavaScript, все скрипты рекомендуется начинать 
с добавления директивы "use strict".

'use strict';

...
Эту директиву следует размещать в первой строке скрипта или в начале тела функции.

Без "use strict" код также запустится, но некоторые возможности будут работать в «режиме совместимости» 
со старыми версиями языка JavaScript.

Урок 15
Качествро кода
1. Фигурные скобки
if (n < 0) {
  console.log(`Степень ${n} не поддерживается`);
}
Для очень короткого кода допустима одна строка. Например: if (cond) return null. Но блок кода 
(последний вариант) обычно всё равно читается лучше.

2.Отступы
  Горизонатльные отступы 2 4 пробела. Например, мы можем выровнять аргументы относительно открывающей
  скобки:

  show(parameters,
       aligned, // 5 пробелов слева
       one,
       after,
       another
    ) {
    // ...
  }
  Вертикальные отступы
  Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация 
  переменных, основной цикл и возвращаемый результат:

function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
Вставляйте дополнительный перевод строки туда, где это сделает код более читаемым. Не должно быть
более 9 строк кода подряд без вертикального отступа.

3. Уровень вложенности 
Например, вместо добавления вложенного условия if, как здесь:

for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- ещё один уровень вложенности
  }
}
Мы можем написать:

for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- нет лишнего уровня вложенности
}



Урок 16
Коментарии

комментарии могут быть однострочными, начинающимися с //, и многострочными: /* ... */.

В хорошем коде должно быть мало коментариев `Если код настолько запутанный, что требует комментариев, 
то, может быть, его стоит переделать?`

Комментируйте:

Общую архитектуру, вид «с высоты птичьего полёта».
Использование функций.
Неочевидные решения, важные детали.

Избегайте комментариев:

Которые объясняют, как работает код, и что он делает.
Используйте их только в тех случаях, когда невозможно сделать настолько простой и 
самодокументированный код, что он не потребует комментариев.

Урок 17
Ниндзя-код. 

Не пиши "как короче", а пиши как понятней
// код из jQuery
i = i ? i < 0 ? Math.max(0, len + i) : i : 0; - так не надо 

не использовать коротныкие имена переменных, типа a,b,c. Но есть одно исключение. В тех местах, 
где однобуквенные переменные общеприняты, например, в счётчике цикла – используйте стандартные
названия i, j, k.

Не  используйте сокращения.list → lst. userAgent → ua. browser → brsr. - так не надо

При выборе имени НЕ применяйте абстрактное слово, например obj, data, value, item, elem и т.п.

Не используйте похожие  имена переменных как date и data

Не используйте русские слова как let ssilka

Не  используйте разные названия для одинаковых обозначений например если метод показывает что-то на 
экране – начните его название с display.. (скажем, displayElement), в другом месте уже НЕ объявляйте
аналогичный метод как show.. (showFrame).

И напротив, если есть две функции с важными отличиями – не используйте одно и то же слово для их описания!
Например, с print... можно начать метод печати на принтере printPage, а также – метод добавления текста 
на страницу printText.

Не используйте повторно одно имя для нескольких переменных

Не добавляйте лишние подчеркивания это только удлиняет код и уменьшает читаемость, например _name; value_;

Имена superElement, megaFrame и niceItem не несёт никакой конкретики. Читающий может решить поискать 
в этом глубинный смысл и замедитировать на часок-другой оплаченного рабочего времени.

Плохо еще использовать  одни и теже названия переменных и в функции и за пределами

Есть функции, название которых говорит о том, что они ничего не меняют. Например, isReady(), 
checkPermission(), findTags()… Предполагается, что при вызове они произведут некие вычисления или найдут
и возвратят полезные данные, но при этом их не изменят. В трактатах это называется
«отсутствие сторонних эффектов». В таких функциях не нужно делать ничего "полезного"

Ограничивайте действия функции тем, что написано в её названии. Например, функция validateEmail(email)
должна проверять email только на правильность, а вывести сообщение об ошибке и просьбой ввести заного
пусть занимктся другая функция  с подходящим названием

Урок 18
Полифилы           ьт                                        
Когда мы используем современные возможности JavaScript, некоторые движки могут не поддерживать их.
И тут приходит на помощь Babel.

Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.
Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

Два интересных хранилища полифилов:

core js поддерживает много функций, можно подключать только нужные.
polyfill.io – сервис, который автоматически создаёт скрипт с полифилом в зависимости от 
необходимых функций и браузера пользователя.

Таким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер 
и добавить полифил.

Большинство примеров можно запустить «на месте», как этот:

console.log('Нажмите кнопку "Play" в крайнем правом углу, чтобы запустить пример');
Примеры, в которых используются современные возможности JS, будут работать, если ваш браузер их 
поддерживает.

Урок 19
Объекты
Используются для хранения коллекций различных значений   

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – 
это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может
быть чем угодно.

Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"

При использованиии литерального синтаксиса { } мы можем поместить сразу несколько своиств в виде пар: `ключ
: значение`

let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};

Можно сказать, что наш объект user – это ящик с двумя папками, подписанными «name» и «age».
Мы можем в любой момент прочесть содержимое папки или удалить его с помощью:
// получаем свойства объекта:
console.log( user.name ); // John
console.log( user.age ); // 30

delete user.age;// для удаления

Значение может быть любого типа. Давайте добавим свойство с логическим значением:
user.isAdmin = true;

Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};



Последнее свойство объекта может заканчиваться запятой:

let user = {
  name: "John",
  age: 30,
}
Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств,
так как все строки объекта становятся одинаковыми.


Объект, объявленный через const, может быть изменён.

Например:

const user = {
  name: "John"
};

user.name = "Pete"; // (*)

console.log(user.name); // Pete
Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том, 
что объявление const защищает от изменений только саму переменную user, а не её содержимое.

Определение const выдаст ошибку только если мы присвоим переменной другое значение: user=....

Для своиств содержащих несколько слов доступ к значению  "через точку" не работает 
// это вызовет синтаксическую ошибку
user.likes birds = true

Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, 
не начинался с цифры и не содержал специальные символы, кроме $ и _. В таком  случае мы используем
квадратные  скобки

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
console.log(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];


Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. 
Например, имя свойства может храниться в переменной:

let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;

Переменная key может зависеть отпользовательского кода, пример:

let user = {
  name: "John",
  age: 30
};

let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
console.log( user[key] ); // John (если ввели "name")
Запись «через точку» такого не позволяет:

let user = {
  name: "John",
  age: 30
};

let key = "name";
console.log( user.key ); // undefined

Своиство из переменной
В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств 
с тем же именем.

Например:

function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}

let user = makeUser("John", 30);
console.log(user.name); // John

Вместо name:name мы можем написать просто name:

Ограничения на имена своиств 
Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, 
такими как «for», «let», «return» и т.д.

Но для свойств объекта такого ограничения нет:

// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

console.log( obj.for + obj.let + obj.return );  // 6
Иными словами, нет никаких ограничений к именам свойств(Кроме свойства __proto__ ). Они могут быть 
в виде строк или символов

Проверка существования своиства, оператор in 
В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к 
любому свойству. Даже если свойства не существует – ошибки не будет!

let user = {};

console.log( user.noSuchProperty === undefined ); // true означает "свойства нет"
Также существует специальный оператор "in" для проверки существования свойства в объекте.

Синтаксис оператора:

"key" in object

Пример:

let user = { name: "John", age: 30 };

console.log( "age" in user ); // true, user.age существует
console.log( "blabla" in user ); // false, user.blabla не существует

Цикл for...in
Синтаксис:

for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

Упорядочение своиств объекта
Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по 
возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.

В качестве примера рассмотрим объект с телефонными кодами:

let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  console.log(code); // 1, 41, 44, 49
}
Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим, чтобы код 49 был первым.

Но если мы запустим код, мы увидим совершенно другую картину:

США (1) идёт первым
затем Швейцария (41) и так далее.
Телефонные коды идут в порядке возрастания, потому что они являются целыми числами: 1, 41, 44, 49.

// Math.trunc - встроенная функция, которая удаляет десятичную часть
console.log( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
console.log( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
console.log( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное

Добавления знака "+" перед каждым кодом будет достаточно.

Пример:

let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
Теперь код работает так, как мы задумывали.


Урок 20
Копирование объектов и их ссылки
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

Например:

let user = { name: "John" };

let admin = user; // копируется ссылка
Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого:

let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // изменено по ссылке из переменной "admin"

alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
Это как если бы у нас был шкафчик с двумя ключами, и мы использовали один из них (admin), чтобы войти
в него и внести изменения. А затем, если мы позже используем другой ключ (user), мы все равно открываем 
тот же шкафчик и можем получить доступ к изменённому содержимому.

Сравнение по ссылке
Два объекта равны только в том случае, если это один и тот же объект.

Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:

let a = {};
let b = a; // копирование по ссылке

alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):

let a = {};
let b = {}; // два независимых объекта

alert( a == b ); // false

Клонирование и объединение, Object.assign

Итак, копирование объектной переменной создаёт ещё одну ссылку на тот же объект.

Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это тоже выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода. 
Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне 
хватает.

Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру 
существующего, перебрав его свойства и скопировав их на примитивном уровне.

Например так:

let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
Также мы можем использовать для этого метод Object.assign.

Синтаксис:

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, 
свойства всех аргументов, начиная со второго, копируются в первый объект.
Возвращает объект dest.
Например, мы можем использовать его для объединения нескольких объектов в один:

let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "John", canView: true, canEdit: true }

Если скопированное имя свойства уже существует, оно будет перезаписано:

let user = { name: "John" };

Object.assign(user, { name: "Pete" });

console.log(user.name); // теперь user = { name: "Pete" }



Строки
const name = "Irik"
console.log(name.lenght) // длина  строки в цыфрах (в данном случае 4)
console.log(name.toUpperCase())//делает все буквы заглавными
console.log(name.toLowerCase())// делает все буквы строчными
console.log(name.charAt(2)) выдает символ который находиться под номером 2
console.log(name.indexOf("rik")) показывает  присуствие и место символа в строке,  если символ  не
нашелся, то выдаст  -1
console.log(name.startsWith())проверяет если сторка начинается с того что в скобках(выдет boolean)
console.log(name.endsWith())
console.log(name.repeat(count:3))
console.log(name.trim) убирает все пробелы
console.log(name.trimRight)убирает пробелы только справа
console.log(name.trimLeft)убирает  пробелы только слева


function logPerson(s, name, age){
  if age<0{
    age = "еще не родился"
  }
  return `${s[0]}${name}${s[1]}${age}${s[2]}`//выдaст Имя: Irik,  Возраст: 20
  console.log(s, name, age)//выведет массив
}
const personName = 'Irik'
const personAge = 20
const output = logPerson`Имя: ${personName}, Востраст: ${personAge}`
console.log(output)



Функции
//Function Declaration
function greet(name){
  console.log('Привет - ', name)
}
greet(name: "Лена")
//Function expresion - когдасоздаем функцию и складываем её в переменную
const greet2 =  function greet2(name){
  console.log("Привет - ", name)
}
greet2(name: "Лена")
//отличия между declaration  и expresion  в том что к function declaration  можно  обращаться когда
//захотим, то есть модно вызвать функцию greet до того как её создать и ничего не поменяется
console.dir(greet)//с помощью dir можно увидить что присутсвует  в функции
//Анонимные функции
let counter = 0
setInterval(handler: function(){
console.log(++counter)
}, timeout:  1000)//через каждые 1000 милесекунд вызывается функция(прибавляется единица)

Стрелочные функции
const arrow = (name) => {
  console.log("Привет,", name)
}
arrow(name: " Лена")

Параметры по умолчанию
const sum = (a, b=1) => a+b
console.log(sum(a:40))// так как b по умолчанию равен 1 то ошиибки не будет, если в console.log добавить
//еще одно значение для b то параметр по умолчанию не защитается

function sumAll(...all){
  const result = 0
  for (let num of all){
  return result += num
  }
  return result
}
const res = (sumAll(all:1,2,3,4,5,6,7))
console.log(res)


Массивы
const cars = [ "Mazda", "Ford", "BMW", "Mercedes"]
методы массива:
cars.push("Reno")// добавит в массив на последнее место
cars.unshift("Volga")//добавит на первое место
cars.shift()//удалит первый элемент в массиве
cars.pop()// удалит последний 
cars.includes("Mazda")//выдаст true
console.log(cars.reverse())//переворачивает массив  с первого на последний, при следуйщем вызове массив
//всё еще  будет  перевернутым
const  index = cars.indexOf("BMW")// выдаст индекск элемента который мы ищем
cars[index] = "Porshe"// заменит BMW на Porshe

const people[
  {name: 'Irik', budget: 4200}
  {name: 'Elena', budget: 3500}
  {name: 'Maxim', budget: 1700}
]
const index = people.findIndex(predicate:function(person){
return person.budget =  3500
})
console.log(index)// укажет место элемента 3500
console.log(people[index])// выведет весь объект где содердится 3500

const carsUpperCase = cars.map(function(car){
  return car.toUpperCase
})
console.log(carsUpperCase)//все элементы  будут написанны большими буквами, но при следуйшем вызове
//всё вернётся обратно

// задача: сложить бюджет  который больше 2000
const people = [
  {name: 'Irik', budget: 4200}
  {name: 'Elena', budget: 3500}
  {name: 'Maxim', budget: 1700}
]
const allBudget= people
.filter(person => person.budget>2000)
.reduce((acc, person) => {
 acc += person.budget
 return acc
},0)
console.log(allBudget)


Объекты
const person ={
  name: 'Irik',
  age: 20,
  isProgramer: false,
  'complex key' : 'Complex Value',//для длинных названий ключей можно использовать строки и назвать ключи 
  // с пробелами
  ['key_' + (1 + 3)] : 'Computed key',//еще один способ написать название сложного  ключа таким образом 
  //ключ будет  равнятся key_4
  languages: ["ru", "ro", "en"],
  greet(){
    console.log("greet from person")
  }
}
console.log(person.name)//одно и тоже
console.log(person['age'])//одно и тоже
console.log(person["complex key"])//сложные названия ключей(с пробелами) выводить только в квадратных
//скобках

person.age++
person.laguages.push('de')
console.log(person)
delete person['key_4']//удаляет

const {name, age, languages} = person //вместо const name=person.name


for (let key in person){
console.log(key)//выдаст все ключи  без значений (name,age,isProgramer...)
if (person.hasOwnProperty(key)){
  console.log('key:', key)
  console.log('value:', person[key])
}
}

const keys = Object.keys(person)
console.log(keys)//получаем массив из объектов([name, age,...])


const logger = {
  keys(){
    console.log("Object Keys:", Object.keys(this))//this тоже самое что написать logger, т.е этого же
    //объекта
  }
  keysAndValues(){
    Object.key(this).forEach(key =>{
      console.log(`"${key}":  ${this[key]}`)
    })
  }
}
const bound = logger.keys.bind()//метод bind привязывает любой контекст который мы выберем
bound()//это функция выведет Object Keys: [keys] то есть logger
logger.keys.call(logger)// почти тоже самое что и bind, только при call не надо создавать и вызывать
//функцию



ОПЦИОНАЛЬНАЯ ЦЕПОЧКА
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. 
равно undefined или null.

Другими словами, value?.prop:

работает как value.prop, если значение value существует,
в противном случае (когда value равно undefined/null) он возвращает undefined.
Вот безопасный способ получить доступ к user.address.street, используя ?.:

let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)
Код лаконичный и понятный, в нем вообще нет дублирования.

А вот пример с document.querySelector:

let html = document.querySelector('.elem')?.innerHTML; // будет undefined, если элемента нет
Считывание адреса с помощью user?.address работает, даже если объект user не существует:

let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
Обратите внимание: синтаксис ?. делает необязательным значение перед ним, но не какое-либо последующее.

Так например, в записи user?.address.street.name ?. позволяет user безопасно быть null/undefined 
(и в этом случае возвращает undefined), но это так только для user. Доступ к последующим свойствам 
осуществляется обычным способом. Если мы хотим, чтобы некоторые из них были необязательными, тогда нам 
нужно будет заменить больше . на ?..

Синтаксис опциональной цепочки ?. имеет три формы:

obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае 
возвращает undefined.
Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть на null/undefined и 
позволяет продолжить вычисление, если это не так.

Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам.

Тем не менее, мы должны использовать ?. осторожно, только там, где по логике кода допустимо, что левая 
часть не существует. Чтобы он не скрывал от нас ошибки программирования, если они возникнут.



Методы примитивов
Примитив

Это – значение «примитивного» типа.
Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, 
Symbol и BigInt. Таким образом, они имеют разный набор методов.

К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

Вот, как он работает:

let str = "Привет";

console.log( str.toUpperCase() ); // ПРИВЕТ
Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает 
значение строки и имеет такие полезные методы, как toUpperCase().
Этот метод запускается и возвращает новую строку (показывается в alert).
Специальный объект удаляется, оставляя только примитив str.

Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального 
объекта. Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Число имеет собственный набор методов. Например, toFixed(n) округляет число до n знаков после запятой.

let num = 1.23456;

console.log( num.toFixed(2) ); // 1.23




let str = "Привет";

str.test = 5;

console.log(str.test);//undefined
Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):

В момент обращения к свойству str создаётся «объект-обёртка».
В строгом режиме, попытка изменения этого объекта выдаёт ошибку.
Без строгого режима, операция продолжается, объект получает свойство test, но после этого он 
удаляется, так что на последней линии str больше не имеет свойства test.
Данный пример наглядно показывает, что примитивы не являются объектами.

Они не могут хранить дополнительные данные


Ключевое слово «this» в методах
Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения 
своей работы.
Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в объекте user.
Для доступа к информации внутри объекта метод может использовать ключевое слово this.
Значение this – это объект «перед точкой», который используется для вызова метода.
Например:

let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" - это "текущий объект".
    alert(this.name);
  }

};

user.sayHi(); // John

Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user).
Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через 
внешнюю переменную (в которой хранится ссылка на этот объект):
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" вместо "this"
  }

};
…Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, 
admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному 
объекту при вызове метода из admin.
Это показано ниже:
	
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // приведёт к ошибке
  }

};


let admin = user;
user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // TypeError: Cannot read property 'name' of null
Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.
«this» не является фиксированным
В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. 
Его можно использовать в любой функции, даже если это не метод объекта.
В следующем примере нет синтаксической ошибки:
function sayHi() {
  alert( this.name );
}
Значение this вычисляется во время выполнения кода, в зависимости от контекста.
Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в 
вызовах:
	
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj. Так что, в приведённом 
выше примере это либо user, либо admin.

У стрелочных функций нет «this»
Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри 
такой функции, то оно берётся из внешней «нормальной» функции.
Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
	
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное this, 
а скорее хотим взять его из внешнего констекста




Конструктор, оператор "new"

Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество 
похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.
Это можно сделать при помощи функции-конструктора и оператора "new".

Функция-конструктор
Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
1. Имя функции-конструктора должно начинаться с большой буквы.
2. Функция-конструктор должна выполняться только с помощью оператора "new".
Например:
	
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false


Когда функция вызывается как new User(...), происходит следующее:
1. Создаётся новый пустой объект, и он присваивается this.
2. Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
3. Возвращается значение this.
Другими словами, new User(...) делает что-то вроде:
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
Таким образом, let user = new User("Jack") возвращает тот же результат, что и:
let user = {
  name: "Jack",
  isAdmin: false
};

Теперь, если нам будет необходимо создать других пользователей, мы можем просто вызвать new User("Ann"), 
new User("Alice") и так далее.

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при 
помощи оператора new или без него.
В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, 
new.target будет равен самой функции.

Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это 
автоматически становится результатом.
Но если return всё же есть, то применяется простое правило:
* 		При вызове return с объектом, вместо this вернётся объект.
* 		При вызове return с примитивным значением, оно проигнорируется.
Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.
К примеру, здесь return замещает this, возвращая объект:
	
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект
А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно):
	
function SmallUser() {

  this.name = "John";

  return; // <-- возвращает this
}

alert( new SmallUser().name );  // John

Создание методов в конструкторе
Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут 
иметь параметры, определяющие, как создавать объект и что в него записывать.
Конечно, мы можем добавить к this не только свойства, но и методы.
Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:
	
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
Для создания сложных объектов есть и более продвинутый синтаксис – классы, который мы рассмотрим позже.


Числа
В современном JavaScript существует два типа чисел:

Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с 
плавающей точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем 
использовать чаще всего. Мы поговорим о них в этой главе.
BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и 
используются в случаях, когда необходимо работать со значениями более чем (253-1) или менее чем -(253-1).
Так как BigInt числа нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.

Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

let billion = 1000000000;
Но в реальной жизни мы обычно опускаем запись множества нулей, так как можно легко ошибиться. 
Укороченная запись может выглядеть как "1млрд" или "7.3млрд" для 7 миллиардов 300 миллионов. Такой 
принцип работает для всех больших чисел.

В JavaScript можно использовать букву "e", чтобы укоротить запись числа. Она добавляется к числу и 
заменяет указанное количество нулей:

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
Другими словами, "e" производит операцию умножения числа на 1 с указанным количеством нулей.

1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
Сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):

let ms = 0.000001;
Записать микросекунду в укороченном виде нам поможет "e".

let ms = 1e-6; // шесть нулей, слева от 1
Если мы подсчитаем количество нулей 0.000001, их будет 6. Естественно, верная запись 1e-6.

Другими словами, отрицательное число после "e" подразумевает деление на 1 с указанным количеством нулей:

// 1 делится на 1 с 3 нулями
1e-3 = 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 = 1.23 / 1000000 (=0.00000123)
Округление
Одна из часто используемых операций при работе с числами – это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:

Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

Забавный пример
Попробуйте выполнить его:

// Привет! Я – число, растущее само по себе!
console.log( 9999999999999999 ); // покажет 10000000000000000
Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, 
остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на 
цифры, то при записи пропадут младшие разряды.

Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере 
выше. Как говорится: «как смог, так записал».

Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая 
бесконечность ∞.
NaN представляет ошибку.
Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции 
для их проверки:

isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN 
уникально тем, что оно не является равным ничему другому, даже самому себе:

alert( NaN === NaN ); // false
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не
NaN/Infinity/-Infinity:

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
Иногда isFinite используется для проверки, содержится ли в строке число:

let num = +prompt("Enter a number", '');

// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert( isFinite(num) );
Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.

Number.isNaN и Number.isFinite
Методы Number.isNaN и Number.isFinite – это более «строгие» версии функций isNaN и isFinite. Они не 
преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (
  принадлежит ли он к типу number).

Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и 
является NaN. Во всех остальных случаях возвращает false.

alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Обратите внимание на разный результат:
alert( Number.isNaN("str") ); // false, так как "str" является строкой, а не числом
alert( isNaN("str") ); // true, так как isNaN сначала преобразует строку "str" в число и в результате 
//преобразования получает NaN
Number.isFinite(value) возвращает true только в том случае, если аргумент принадлежит к типу number и 
не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.

alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Обратите внимание на разный результат:
alert( Number.isFinite("123") ); // false, так как "123" является строкой, а не числом
alert( isFinite("123") ); // true, так как isFinite сначала преобразует строку "123" в число 123
Не стоит считать Number.isNaN и Number.isFinite более «корректными» версиями функций isNaN и isFinite. 
Это дополняющие друг-друга инструменты для разных задач.


Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в 
двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения 
разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму 
необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is 
(Определение SameValue).

parseInt и parseFloat
Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности 
числом, то результат будет NaN:

alert( +"100px" ); // NaN
Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.

В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например "100px" 
или "12pt" в CSS. Также во множестве стран символ валюты записывается после номинала "19€". Так как нам 
получить числовое значение из таких строк?

Для этого есть parseInt и parseFloat.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до 
ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:

alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом 
parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456

В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
Math.pow(n, power)
Возвращает число n, возведённое в степень power

alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
В объекте Math есть множество функций и констант, включая тригонометрические функции

Для проверки на NaN и Infinity:

isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN
isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity
Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не 
является NaN/Infinity/-Infinity



Строки
В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», 
который есть в ряде других языков.

Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

Кавычки
В JavaScript есть разные типы кавычек.

Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, 
то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
Выглядит вполне естественно, не правда ли? Что тут такого? Но если попытаться использовать точно так же 
одинарные или двойные кавычки, то будет ошибка:

let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";

Спецсимволы
Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый 
«символ перевода строки», который записывается как \n:

let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // список гостей, состоящий из нескольких строк
В частности, эти две строки эквивалентны, просто записаны по-разному:

// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

alert(str1 == str2); // true
Есть и другие, реже используемые спецсимволы. Вот список:

Символ	Описание
\n	Перевод строки
\r	В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других 
ОС это просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.
\', \", \`	Кавычки
\\	Обратный слеш
\t	Знак табуляции
\b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не 
используются.

Как вы можете видеть, все спецсимволы начинаются с обратного слеша, \ — так называемого «символа 
экранирования».

Он также используется, если необходимо вставить в строку кавычку.

К примеру:

alert( 'I\'m the Walrus!' ); // I'm the Walrus!
Заметим, что обратный слеш \ служит лишь для корректного прочтения строки интерпретатором, но он не 
записывается в строку после её прочтения. Когда строка сохраняется в оперативную память, в неё не
 добавляется символ \. Вы можете явно видеть это в выводах alert в примерах выше.

Но что, если нам надо добавить в строку собственно сам обратный слеш \?

Это можно сделать, добавив перед ним… ещё один обратный слеш!

alert( `The backslash: \\` ); // The backslash: \
Длина строки
Свойство length содержит длину строки:

alert( `My\n`.length ); // 3
Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.

Доступ к символам
Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. 
Также можно использовать метод str.at(pos). Первый символ занимает нулевую позицию:

let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) ); // o

Как вы можете видеть, преимущество метода .at(pos) заключается в том, что он допускает 
отрицательную позицию. Если pos – отрицательное число, то отсчет ведется от конца строки.

Таким образом, .at(-1) означает последний символ, а .at(-2) – тот, что перед ним, и т.д.

Квадратные скобки всегда возвращают undefined для отрицательных индексов. Например:

let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
Также можно перебрать строку посимвольно, используя for..of:

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}

Строки неизменяемы
Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. 
Как только строка создана — она такая навсегда.

Давайте попробуем так сделать, и убедимся, что это не работает:

let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает
Можно создать новую строку и записать её в ту же самую переменную вместо старой.

Например:

let str = 'Hi';

str = 'h' + str[1]; // заменяем строку

alert( str ); // hi

Поиск подстроки
Существует несколько способов поиска подстроки.

str.indexOf
Первый метод — str.indexOf(substr, pos).

Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на 
которой располагается совпадение, либо -1 при отсутствии совпадений.

Например:

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
Необязательный второй аргумент позволяет начать поиск с определённой позиции.

str.lastIndexOf(substr, position)
Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.

Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или 
начинающееся до (включительно) определённой позиции.

При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать:

let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("Совпадение есть"); // не работает
}
Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, 
т. к. str.indexOf("Widget") возвращает 0, и if решает, что тест не пройден.

Поэтому надо делать проверку на -1:

let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}

Трюк с побитовым НЕ
Существует старый трюк с использованием побитового оператора НЕ — ~. Он преобразует число в 32-разрядное целое со знаком (signed 32-bit integer). Дробная часть, в случае, если она присутствует, отбрасывается. Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение ~n равно -(n+1).

В частности:

alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
alert( ~-1 ); // 0, то же, что -(-1+1)
Таким образом, ~n равняется 0 только при n == -1 (для любого n, входящего в 32-разрядные целые числа 
со знаком).

Соответственно, прохождение проверки if ( ~str.indexOf("…") ) означает, что результат indexOf отличен 
от -1, совпадение есть.

Это иногда применяют, чтобы сделать проверку indexOf компактнее:

let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( 'Совпадение есть' ); // работает
}

includes, startsWith, endsWith
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока 
substr, либо false, если нет.

Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка 
определённой строкой:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

Получение подстроки
В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

Например:

let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как 
заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
str.substring(start [, end])
Возвращает часть строки между start и end (не включая) end.

Это — почти то же, что и slice, но можно задавать start больше end.
Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами.

Например:

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)
Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

str.substr(start [, length])
Возвращает часть строки от start длины length.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );
Этот метод находится в Annex B спецификации языка. Это означает, что его должны поддерживать только 
браузерные движки JavaScript, и использовать его не рекомендуется. Но на практике он поддерживается везде.

Давайте подытожим, как работают эти методы, чтобы не запутаться:

метод	выбирает…	отрицательные значения
slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end (не включая end)	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным


Сравнение строк
Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

Тем не менее, есть некоторые нюансы.

Строчные буквы больше заглавных:

alert( 'a' > 'Z' ); // true
Буквы, имеющие диакритические знаки, идут «не по порядку»:

alert( 'Österreich' > 'Zealand' ); // true
Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, 
что Zealand будет после Österreich в списке.

Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные 
методы, позволяющие получить символ по его коду и наоборот.

str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
String.fromCodePoint(code)
Создаёт символ по его коду code

alert( String.fromCodePoint(90) ); // Z

Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые 
распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и Ö ближе к концу 
вывода.

Теперь очевидно, почему a > Z.

Символы сравниваются по их кодам. Больший код — больший символ. Код a (97) больше кода Z (90).

Все строчные буквы идут после заглавных, так как их коды больше.
Некоторые буквы, такие как Ö, вообще находятся вне основного алфавита. У этой буквы код больше, чем у 
любой буквы от a до z.

Правильное сравнение
«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют 
разные алфавиты.

Поэтому браузеру нужно знать, какой язык использовать для сравнения.

К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека Intl.JS) поддерживают 
стандарт ECMA 402, обеспечивающий правильное сравнение строк на разных языках с учётом их правил.

Для этого есть соответствующий метод.

Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с 
правилами языка:

Отрицательное число, если str меньше str2.
Положительное число, если str больше str2.
0, если строки равны.
Например:

alert( 'Österreich'.localeCompare('Zealand') ); // -1
У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать 
язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить 
дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия 
между "a" и "á".


Массивы
Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 
1-й, 2-й, 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, 
товаров, элементов HTML и т.д.

В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком 
элементов. Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены 
для этих целей.

Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.
Объявление
Существует два варианта синтаксиса для создания пустого массива:

let arr = new Array();
let arr = [];
Практически всегда используется второй вариант синтаксиса. В скобках мы можем указать начальные значения
элементов:

let fruits = ["Яблоко", "Апельсин", "Слива"];
Общее число элементов массива содержится в его свойстве length:

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3
В массиве могут храниться элементы любого типа.

Например:

// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет
Висячая запятая
Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
];
«Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.

Для получения послледнего элемента из массива используем at
К счастью, есть более короткий синтаксис: fruits.at(-1):

let fruits = ["Apple", "Orange", "Plum"];
// то же самое, что и fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum

Методы pop/push, shift/unshift
Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так 
называется упорядоченная коллекция элементов, поддерживающая два вида операций:

push добавляет элемент в конец.
shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

Массивы поддерживают обе операции.

Она поддерживает два вида операций:

push добавляет элемент в конец.
pop удаляет последний элемент.
Таким образом, новые элементы всегда добавляются или удаляются из «конца».

Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:

Методы, работающие с концом массива:

pop
Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удаляем "Груша" и выводим его

alert( fruits ); // Яблоко, Апельсин

push
Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, 
следовательно, ведёт себя как объект.

Например, копируется по ссылке:

let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert( arr === fruits ); // true

arr.push("Груша"); // массив меняется по ссылке

alert( fruits ); // Банан, Груша - теперь два элемента

Методы, работающие с началом массива:

shift
Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удаляем Яблоко и выводим его

alert( fruits ); // Апельсин, Груша
unshift
Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша
Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );

Почему работать с концом массива быстрее, чем с его началом? Давайте посмотрим, что происходит во время 
выполнения:

fruits.shift(); // удаляем первый элемент с начала
Просто взять и удалить элемент с номером 0 недостаточно. Нужно также заново пронумеровать остальные 
элементы.

Операция shift должна выполнить 3 действия:

Удалить элемент с индексом 0.
Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
Обновить свойство length .

Перебор элементов
Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в 
большинстве случаев этого достаточно. А также это короче.

Технически, так как массив является объектом, можно использовать и вариант for..in:

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}

Немного о «length»
Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество 
элементов массива, а наибольший цифровой индекс плюс один.

Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fruits = [];
fruits[123] = "Яблоко";

alert( fruits.length ); // 124

Ещё один интересный факт о свойстве length – его можно перезаписать.

Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив 
станет короче. Этот процесс необратим, как мы можем понять из примера:

let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert( arr ); // [1, 2]

arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились
Таким образом, самый простой способ очистить массив – это arr.length = 0;.

Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив 
без элементов, но с заданной длиной.

Давайте посмотрим, как можно оказать себе медвежью услугу:

let arr = new Array(2); // создастся ли массив [2]?

alert( arr[0] ); // undefined! нет элементов.

alert( arr.length ); // length 2

Многомерные массивы
Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания 
многомерных массивов, например, для хранения матриц:

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральный элемент

toString
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

Например:

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"

Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование 
toString, таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2"

Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку

В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при 
помощи оператора ==.

У этого оператора нет специального подхода к массивам, он работает с ними, как и с любыми другими 
объектами.

Давайте ещё раз напомним правила:

Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив, 
как описано в главе Преобразование объектов в примитивы.
…За исключением null и undefined, которые равны == друг другу и ничему больше.
Оператор строгого равенства === ещё проще, так как он не преобразует типы.

Итак, если мы всё же сравниваем массивы с помощью ==, то они никогда не будут одинаковыми, если только мы 
не сравним две переменные, которые ссылаются на один и тот же массив

Например:

alert( [] == [] ); // false
alert( [0] == [0] ); // false

Технически эти массивы являются разными объектами. Так что они не равны. Оператор == не выполняет 
поэлементное сравнение.

Сравнение с примитивами также может дать, казалось бы, странные результаты:

alert( 0 == [] ); // true

alert('0' == [] ); // false
Здесь, в обоих случаях, мы сравниваем примитив с объектом массива. Таким образом, массив [] преобразуется 
в примитив с целью сравнения и становится пустой строкой ''.

Затем продолжается процесс сравнения с примитивами, как описано в главе Преобразование типов:

/ после того, как [] был преобразован в ''
alert( 0 == '' ); // true, так как '' преобразуется в число 0

alert('0' == '' ); // false, нет преобразования типов, разные строки
Так как же сравнить массивы?

Это просто: не используйте оператор ==. Вместо этого сравните их по элементам в цикле или используя 
методы итерации, описанные в следующей главе.


Методы массивов
splice
Как удалить элемент из массива?

Так как массивы – это объекты, то можно попробовать delete:

let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
Элемент был удалён, но в массиве всё ещё три элемента, мы можем увидеть, что arr.length == 3.

Это естественно, потому что delete obj.key удаляет значение по ключу key. Это всё, что он делает. Хорошо 
для объектов. Но для массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли 
освободившееся место. Мы ждём, что массив станет короче.

Поэтому нужно использовать специальные методы.

Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, 
удалять и заменять элементы.

Синтаксис:

arr.splice(start[, deleteCount, elem1, ..., elemN])
Он изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., 
elemN на их место. Возвращает массив из удалённых элементов.

Этот метод легко понять, рассмотрев примеры.

Начнём с удаления:

let arr = ["Я", "изучаю", "JavaScript"];

arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

alert( arr ); // осталось ["Я", "JavaScript"]
Легко, правда? Начиная с индекса 1, он убрал 1 элемент.

В следующем примере мы удалим 3 элемента и заменим их двумя другими.

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
Здесь видно, что splice возвращает массив из удалённых элементов:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

let arr = ["Я", "изучаю", "JavaScript"];

// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

slice
Метод arr.slice намного проще, чем похожий на него arr.splice.

Синтаксис:

arr.slice([start], [end])
Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). 
start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.

Например:

let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
Можно вызвать slice без аргументов: arr.slice() создаёт копию arr. Это часто используют, чтобы создать 
копию массива для дальнейших преобразований, которые не должны менять исходный массив.

concat
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные 
значения.

Синтаксис:

arr.concat(arg1, arg2...)
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

В результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.

Если аргумент argN – массив, то копируются все его элементы. Иначе копируется сам аргумент.

Например:

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, 
добавляются как есть:

let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
…Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он 
обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:

let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё

Перебор: forEach
Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

Синтаксис:

arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
Например, этот код выведет на экран каждый элемент массива:

// Вызов alert для каждого элемента
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);
А этот вдобавок расскажет и о позиции элемента в целевом массиве:

["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);
});
Результат функции (если она что-то возвращает) отбрасывается и игнорируется.

Поиск в массиве
Теперь рассмотрим методы поиска в массиве.

indexOf/lastIndexOf и includes
У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:

arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
Обычно эти методы используются только с одним аргументом: искомым item. По умолчанию поиск ведется с начала.

Например:

let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем
 false, он находит именно false, а не ноль.

Если мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно
 использовать arr.includes.

Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.

let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')
Метод includes правильно обрабатывает NaN
Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие
 от indexOf:

const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)
alert( arr.includes(NaN) );// true (верно)
Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный
алгоритм сравнения.

find и findIndex/findLastIndex
Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?

Здесь пригодится метод arr.find.

Синтаксис:

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
Функция вызывается по очереди для каждого элемента массива:

item – очередной элемент.
index – его индекс.
array – сам массив.
Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается
 undefined.

Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Найдем пользователя 
с id == 1:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.

Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1 с одним аргументом. 
Это типично, другие аргументы этой функции используются редко.

У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не 
сам элемент. Значение -1 возвращается, если ничего не найдено.

Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.

Например:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"},
  {id: 4, name: "Вася"}
];

// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0

// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3

filter
Метод find ищет один (первый) элемент, который заставит функцию вернуть true.

Если найденных элементов может быть много, можно использовать arr.filter(fn).

Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
Например:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2

map
Метод arr.map является одним из наиболее полезных и часто используемых.

Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

Синтаксис:

let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6

sort(fn)
Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как 
изменяется сам arr.

Например:

let arr = [ 1, 2, 15 ];

// метод сортирует содержимое arr
arr.sort();

alert( arr );  // 1, 15, 2
Не заметили ничего странного в этом примере?

Порядок стал 1, 15, 2. Это неправильно. Но почему?

По умолчанию элементы сортируются как строки.

Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический 
порядок, и действительно выходит, что "2" > "15".

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве 
аргумента arr.sort().

Функция должна для пары значений возвращать:

function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
Например, для сортировки чисел:

function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
Теперь всё работает как надо.

Сделаем отступление и подумаем, что происходит. arr может быть массивом чего угодно, верно? Он может 
содержать числа, строки, объекты или что-то ещё. У нас есть набор каких-то элементов. Чтобы отсортировать 
его, нам нужна упорядочивающая функция, которая знает, как сравнивать его элементы. По умолчанию элементы 
сортируются как строки.

Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает 
внутри (в большинстве случаев это оптимизированная быстрая сортировка или Timsort). Она проходится по 
массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что нам 
нужно, – предоставить fn, которая делает сравнение.

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их 
на экран:

[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
В процессе работы алгоритм может сравнивать элемент со множеством других, но он старается сделать как 
можно меньше сравнений.

Функция сравнения может вернуть любое число
На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и 
отрицательное число, чтобы сказать «меньше».

Это позволяет писать более короткие функции:

let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
Лучше использовать стрелочные функции
Помните стрелочные функции? Можно использовать их здесь для того, чтобы сортировка выглядела более 
аккуратной:

arr.sort( (a, b) => a - b );
Будет работать точно так же, как и более длинная версия выше.

Используйте localeCompare для строк
Помните алгоритм сравнения строк? По умолчанию, он сравнивает буквы по их кодам.

Для многих алфавитов лучше использовать метод str.localeCompare, для правильной сортировки букв, таких 
как Ö.

Например, отсортируем несколько стран на немецком языке:

let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)

reverse
Метод arr.reverse меняет порядок элементов в arr на обратный.

Например:

let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
Он также возвращает массив arr с изменённым порядком элементов.

split и join
Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, 
кому его отправить, через запятую: Вася, Петя, Маша. Но нам-то гораздо удобнее работать с массивом имён, 
чем с одной строкой. Как его получить?

Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.

В примере ниже таким разделителем является строка из запятой и пробела.

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в 
массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко 
используется:

let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

alert(arr); // Вася, Петя
Разбивка по буквам
Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:

let str = "тест";

alert( str.split('') ); // т,е,с,т
Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, 
вставляя glue между ними.

Например:

let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша

split и join
Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, 
кому его отправить, через запятую: Вася, Петя, Маша. Но нам-то гораздо удобнее работать с массивом имён, 
чем с одной строкой. Как его получить?

Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.

В примере ниже таким разделителем является строка из запятой и пробела.

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в 
массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко 
используется:

let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

alert(arr); // Вася, Петя
Разбивка по буквам
Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:

let str = "тест";

alert( str.split('') ); // т,е,с,т
Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, 
вставляя glue между ними.

Например:

let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша
reduce/reduceRight
Когда нам нужно перебрать массив – мы можем использовать forEach, for или for..of.

Когда нам нужно перебрать массив и вернуть данные для каждого элемента – мы можем использовать map.

Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. Они используются для 
вычисления единого значения на основе всего массива.

Синтаксис:

let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан 
  initial),
item – очередной элемент массива,
index – его позиция,
array – сам массив.
При вызове функции результат её предыдущего вызова передаётся на следующий вызов в качестве первого 
аргумента.

Так, первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих вызовов функции. По окончании он становится результатом reduce.

Звучит сложно?

Этот метод проще всего понять на примере.

Тут мы получим сумму всех элементов массива одной строкой:

let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
Функция, переданная в reduce, использует только два аргумента, этого обычно достаточно.

Разберём детально как это работает.

При первом запуске sum равен initial (последний аргумент reduce), то есть 0, а current – первый элемент 
массива, равный 1. Таким образом, результат функции равен 1.
При втором запуске sum = 1, к нему мы добавляем второй элемент массива (2) и возвращаем.
При третьем запуске sum = 3, к которому мы добавляем следующий элемент, и так далее…
Поток вычислений получается такой:


Или в виде таблицы, где каждая строка показывает вызов функции на очередном элементе массива:

sum	current	result
первый вызов	0	1	1
второй вызов	1	2	3
третий вызов	3	3	6
четвёртый вызов	6	4	10
пятый вызов	10	5	15
Здесь отчётливо видно, как результат предыдущего вызова передаётся в первый аргумент следующего.

Мы также можем опустить начальное значение:

let arr = [1, 2, 3, 4, 5];

// убрано начальное значение (нет 0 в конце)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения берётся 
первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же за вычетом первой строки.

Но такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального 
значения выдаст ошибку.

Вот пример:

let arr = [];

// Error: Reduce of empty array with no initial value
// если бы существовало начальное значение, reduce вернул бы его для пустого массива.
arr.reduce((sum, current) => sum + current);
Поэтому рекомендуется всегда указывать начальное значение.

Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.

Array.isArray
Массивы не образуют отдельный тип языка. Они основаны на объектах.

Поэтому typeof не может отличить простой объект от массива:

alert(typeof {}); // object
alert(typeof []); // тоже object
…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). 
Он возвращает true, если value массив, и false, если нет.

alert(Array.isArray({})); // false

alert(Array.isArray([])); // true

Большинство методов поддерживают «thisArg»
Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода 
sort, принимают необязательный параметр thisArg.

Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания 
темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:

arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg -- необязательный последний аргумент
Значение параметра thisArg становится this для func.

Например, тут мы используем метод объекта army как фильтр, и thisArg передаёт ему контекст:

let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
Если бы мы в примере выше использовали просто users.filter(army.canJoin), то вызов army.canJoin был бы в 
режиме отдельной функции, с this=undefined. Это тут же привело бы к ошибке.

Вызов users.filter(army.canJoin, army) можно заменить на users.filter(user => army.canJoin(user)), который 
делает то же самое. Последняя запись используется даже чаще, так как функция-стрелка более наглядна.

Итого
Шпаргалка по методам массива:

Для добавления/удаления элементов:

push(...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. 
Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если 
ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых 
через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый 
массив.
split/join – преобразует строку в массив и обратно.
reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для 
каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.
Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют 
исходный массив.

Эти методы – самые используемые, их достаточно в 99% случаев. Но существуют и другие:

arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов 
являются true, то метод возвращает true, иначе false.

Эти методы ведут себя примерно так же, как операторы || и &&: если fn возвращает истинное значение, 
arr.some() немедленно возвращает true и останавливает перебор остальных элементов; если fn возвращает 
ложное значение, arr.every() немедленно возвращает false и также прекращает перебор остальных элементов.

Мы можем использовать every для сравнения массивов:

function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная с позиции start и заканчивая end, в 
себя, на позицию target (перезаписывая существующие).

arr.flat(depth)/arr.flatMap(fn) создаёт новый плоский массив из многомерного массива.

Полный список есть в справочнике MDN.

На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно 
запомнить. Но это гораздо проще, чем кажется.

Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, 
предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.

Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – 
приходите сюда, смотрите на таблицу и ищите правильный метод. Примеры помогут вам всё сделать правильно, 
и вскоре вы быстро запомните методы без особых усилий.



ПЕРЕБЕРАЕМЫЕ ОБЪЕКТЫ
Перебираемые (или итерируемые) объекты – это обобщение массивов. Концепция, которая позволяет использовать 
любой объект в цикле for..of.

Конечно же, сами массивы являются перебираемыми объектами. Но есть и много других встроенных перебираемых 
объектов, например, строки.

Если объект не является массивом, но представляет собой коллекцию каких-то элементов (список, набор), то удобно 
использовать цикл for..of для их перебора, так что давайте посмотрим, как это сделать.
Symbol.iterator
Мы легко поймём принцип устройства перебираемых объектов, создав один из них.

Например, у нас есть объект. Это не массив, но он выглядит подходящим для for..of.

Например, объект range, который представляет собой диапазон чисел:

let range = {
  from: 1,
  to: 5
};

// Мы хотим, чтобы работал for..of:
// for(let num of range) ... num=1,2,3,4,5

У самого range нет метода next().
Вместо этого другой объект, так называемый «итератор», создаётся вызовом range[Symbol.iterator](), и именно его 
next() генерирует значения.
Таким образом, объект итератор отделён от самого итерируемого объекта.

Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код.

Например, вот так:

let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
Теперь range[Symbol.iterator]() возвращает сам объект range: у него есть необходимый метод next(), и он 
запоминает текущее состояние итерации в this.current. Короче? Да. И иногда такой способ тоже хорош.

Недостаток такого подхода в том, что теперь мы не можем использовать этот объект в двух параллельных циклах 
for..of: у них будет общее текущее состояние итерации, потому что теперь существует лишь один итератор – сам 
объект. Но необходимость в двух циклах for..of, выполняемых одновременно, возникает редко, даже при наличии 
асинхронных операций.

Бесконечные итераторы
Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity. Или мы можем 
создать итерируемый объект, который генерирует бесконечную последовательность псевдослучайных чисел. Это бывает 
полезно.

Метод next не имеет ограничений, он может возвращать всё новые и новые значения, это нормально.

Конечно же, цикл for..of с таким итерируемым объектом будет бесконечным. Но мы всегда можем прервать его, 
используя break.

Строка – перебираемый объект
Среди встроенных перебираемых объектов наиболее широко используются массивы и строки.

Для строки for..of перебирает символы:

for (let char of "test") {
  // срабатывает 4 раза: по одному для каждого символа
  alert( char ); // t, затем e, затем s, затем t
}
И он работает корректно даже с суррогатными парами!

let str = '𝒳😂';
for (let char of str) {
    console.log( char ); // 𝒳, а затем 😂
}

Явный вызов итератора
Чтобы понять устройство итераторов чуть глубже, давайте посмотрим, как их использовать явно.

Мы будем перебирать строку точно так же, как цикл for..of, но вручную, прямыми вызовами. Нижеприведённый код 
получает строковый итератор и берёт из него значения:

let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
Такое редко бывает необходимо, но это даёт нам больше контроля над процессом, чем for..of. Например, мы можем 
разбить процесс итерации на части: перебрать немного элементов, затем остановиться, сделать что-то ещё и потом 
продолжить.

Итерируемые объекты и псевдомассивы
Есть два официальных термина, которые очень похожи, но в то же время сильно различаются. Поэтому убедитесь, 
что вы как следует поняли их, чтобы избежать путаницы.

Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.
При использовании JavaScript в браузере или других окружениях мы можем встретить объекты, которые являются 
итерируемыми или псевдомассивами, или и тем, и другим.

Например, строки итерируемы (для них работает for..of) и являются псевдомассивами (они индексированы и есть 
  length).

Но итерируемый объект может не быть псевдомассивом. И наоборот: псевдомассив может не быть итерируемым.

Например, объект range из примера выше – итерируемый, но не является псевдомассивом, потому что у него нет 
индексированных свойств и length.

А вот объект, который является псевдомассивом, но его нельзя итерировать:

let arrayLike = { // есть индексы и свойство length => псевдомассив
  0: "Hello",
  1: "World",
  length: 2
};

// Ошибка (отсутствует Symbol.iterator)
for (let item of arrayLike) {}
Что у них общего? И итерируемые объекты, и псевдомассивы – это обычно не массивы, у них нет методов push, 
pop и т.д. Довольно неудобно, если у нас есть такой объект и мы хотим работать с ним как с массивом. Например, 
мы хотели бы работать с range, используя методы массивов. Как этого достичь?

Array.from
Есть универсальный метод Array.from, который принимает итерируемый объект или псевдомассив и делает из него 
«настоящий» Array. После этого мы уже можем использовать методы массивов.

Например:

let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
Array.from в строке (*) принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, 
затем создаёт новый массив и копирует туда все элементы.

То же самое происходит с итерируемым объектом:

// range взят из примера выше
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)
Полный синтаксис Array.from позволяет указать необязательную «трансформирующую» функцию:

Array.from(obj[, mapFn, thisArg])
Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед 
добавлением в массив, а thisArg позволяет установить this для этой функции.

Например:

// range взят из примера выше

// возводим каждое число в квадрат
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
Здесь мы используем Array.from, чтобы превратить строку в массив её элементов:

let str = '𝒳😂';

// разбивает строку на массив её элементов
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
В отличие от str.split, этот метод в работе опирается на итерируемость строки, и поэтому, как и for..of, он 
корректно работает с суррогатными парами.

Технически это то же самое, что и:

let str = '𝒳😂';

let chars = []; // Array.from внутри себя выполняет тот же цикл
for (let char of str) {
  chars.push(char);
}

alert(chars);
…Но гораздо короче.

Мы можем даже создать slice, который поддерживает суррогатные пары:

function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// а вот встроенный метод не поддерживает суррогатные пары
alert( str.slice(1, 3) ); // мусор (две части различных суррогатных пар)

Map и Set
Сейчас мы знаем о следующих сложных структурах данных:

Объекты для хранения именованных коллекций.
Массивы для хранения упорядоченных коллекций.
Но этого не всегда достаточно для решения повседневных задач. Поэтому также существуют Map и Set.

Map
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать 
ключи любого типа.

Методы и свойства:

new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.

let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3

map[key] это не совсем правильный способ использования Map
Хотя map[key] также работает, например, мы можем установить map[key] = 2, в этом случаеmap рассматривался бы 
как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только 
строки/символьные ключи и так далее).

Поэтому нам следует использовать методы map: set, get и так далее.

Map может использовать объекты в качестве ключей.

Например:

let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123

Использование объектов в качестве ключей – одна из наиболее заметных и важных функций Map. Это то что 
невозможно для Object. Строка в качестве ключа в Object – это нормально, но мы не можем использовать другой 
Object в качестве ключа в Object.

Давайте попробуем заменить Map на Object:

let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет 
замещён

// Вот что там было записано!
alert( visitsCountObj["[object Object]"] ); // 123
Так как visitsCountObj является объектом, он преобразует все ключи Object, такие как john и ben, в одну и 
ту же строку "[object Object]". Это определенно не то, чего мы хотим.


Как объект Map сравнивает ключи
Чтобы сравнивать ключи, объект Map использует алгоритм SameValueZero. Это почти такое же сравнение, что и ===, 
с той лишь разницей, что NaN считается равным NaN. Так что NaN также может использоваться в качестве ключа.

Этот алгоритм не может быть заменён или модифицирован.

Цепочка вызовов
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");

  Перебор Map
  Для перебора коллекции Map есть 3 метода:
  
  map.keys() – возвращает итерируемый объект по ключам,
  map.values() – возвращает итерируемый объект по значениям,
  map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по 
  умолчанию в for..of.
  Например:
  
  let recipeMap = new Map([
    ["огурец", 500],
    ["помидор", 350],
    ["лук",    50]
  ]);
  
  // перебор по ключам (овощи)
  for (let vegetable of recipeMap.keys()) {
    alert(vegetable); // огурец, помидор, лук
  }
  
  // перебор по значениям (числа)
  for (let amount of recipeMap.values()) {
    alert(amount); // 500, 350, 50
  }
  
  // перебор по элементам в формате [ключ, значение]
  for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
    alert(entry); // огурец,500 (и так далее)
  }

  Используется порядок вставки
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление 
элементов.

Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});

Object.entries: Map из Object
При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для 
инициализации, как здесь:

// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет встроенный метод 
Object.entries(obj), который получает объект и возвращает массив пар ключ-значение для него, как раз в этом 
формате.

Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John

Здесь Object.entries возвращает массив пар ключ-значение: [ ["name","John"], ["age", 30] ]. Это именно то, 
что нужно для создания Map.

Object.fromEntries: Object из Map
Мы только что видели, как создать Map из обычного объекта при помощи Object.entries(obj).

Есть метод Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он 
создаёт из них объект:

let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2

Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.

Вот как это сделать:

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2

Вызов map.entries() возвращает итерируемый объект пар ключ/значение, как раз в нужном формате для 
Object.fromEntries.

Мы могли бы написать строку (*) ещё короче:

let obj = Object.fromEntries(map); // убрать .entries()

Это то же самое, так как Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно 
массив. А перебор map как раз возвращает пары ключ/значение, так же, как и map.entries(). Так что в итоге у 
нас будет обычный объект с теми же ключами/значениями, что и в map.

Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться 
только один раз.

Его основные методы это:

new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это 
  массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе 
false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.
Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не 
происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить 
к дубликатам. Каждый посетитель должен появиться в списке только один раз.

Множество Set – как раз то, что нужно для этого:

let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}

Альтернативой множеству Set может выступать массив для хранения гостей и дополнительный код для проверки уже 
имеющегося элемента с помощью arr.find. Но в этом случае будет хуже производительность, потому что arr.find 
проходит весь массив для проверки наличия элемента. Множество Set лучше оптимизировано для добавлений, оно 
автоматически проверяет на уникальность.

Перебор объекта Set
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:

let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое 
значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке 
аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного 
странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

Set имеет те же встроенные методы, что и Map:

set.keys() – возвращает перебираемый объект для значений,
set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной 
совместимости с Map.

WeakMap и WeakSet
Как мы знаем из главы Сборка мусора, движок JavaScript хранит значения в памяти до тех пор, пока они достижимы 
(то есть, эти значения могут быть использованы).

Например:

let john = { name: "John" };

// объект доступен, переменная john -- это ссылка на него

// перепишем ссылку
john = null;

// объект будет удалён из памяти
Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в 
памяти до тех пор, пока эта структура данных содержится в памяти.

Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет 
существовать в памяти, несмотря на то, что других ссылок на него нет.

Например:

let john = { name: "John" };

let array = [ john ];

john = null; // перезаписываем ссылку на объект

// объект john хранится в массиве, поэтому он не будет удалён сборщиком мусора
// мы можем взять его значение как array[0]

Аналогично, если мы используем объект как ключ в Map, то до тех пор, пока существует Map, также будет 
существовать и этот объект. Он занимает место в памяти и не может быть удалён сборщиком мусора.

Например:

let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john сохранён внутри объекта `Map`,
// он доступен через map.keys()

WeakMap – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком 
мусора, когда эти объекты выступают в качестве ключей.

Давайте посмотрим, что это означает, на примерах.

WeakMap
Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект

Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён 
из памяти (и из объекта WeakMap) автоматически.

let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!

Сравните это поведение с поведением обычного Map, пример которого был приведён ранее. Теперь john существует 
только как ключ в WeakMap и может быть удалён оттуда автоматически.

WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или 
значения из неё.

В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)
К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим 
(как объект john в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, 
в какой момент произойдёт эта очистка.

Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как 
удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз 
позже. Так что технически количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку 
сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям 
недоступны.

Но для чего же нам нужна такая структура данных?

Пример: дополнительные данные
В основном, WeakMap используется в качестве дополнительного хранилища данных.

Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и 
хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, 
то WeakMap – как раз то, что нужно.

Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, 
ассоциированные с ними данные тоже автоматически исчезнут.

weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены
Давайте рассмотрим один пример.

Предположим, у нас есть код, который ведёт учёт посещений для пользователей. Информация хранится в коллекции 
Map: объект, представляющий пользователя, является ключом, а количество визитов – значением. Когда пользователь 
нас покидает (его объект удаляется сборщиком мусора), то больше нет смысла хранить соответствующий счётчик 
посещений.

Вот пример реализации счётчика посещений с использованием Map:

// 📁 visitsCount.js
let visitsCountMap = new Map(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

А вот другая часть кода, возможно, в другом файле, которая использует countUser:

// 📁 main.js
let john = { name: "John" };

countUser(john); //ведём подсчёт посещений

// пользователь покинул нас
john = null;

Теперь объект john должен быть удалён сборщиком мусора, но он продолжает оставаться в памяти, так как является 
ключом в visitsCountMap.

Нам нужно очищать visitsCountMap при удалении объекта пользователя, иначе коллекция будет бесконечно расти. 
Подобная очистка может быть неудобна в реализации при сложной архитектуре приложения.

Проблемы можно избежать, если использовать WeakMap:

// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
Теперь нет необходимости вручную очищать visitsCountMap. После того, как объект john стал недостижим другими 
способами, кроме как через WeakMap, он удаляется из памяти вместе с информацией по такому ключу из WeakMap.

Применение для кеширования
Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться 
(«кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый 
результат, повторно используя его.

Для хранения результатов мы можем использовать Map, вот так:

// 📁 cache.js
let cache = new Map();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* тут какие-то вычисления результата для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// Теперь используем process() в другом файле:

// 📁 main.js
let obj = {/* допустим, у нас есть какой-то объект */};

let result1 = process(obj); // вычислен результат

// ...позже, из другого места в коде...
let result2 = process(obj); // ранее вычисленный результат взят из кеша

// ...позже, когда объект больше не нужен:
obj = null;

alert(cache.size); // 1 (Упс! Объект всё ещё в кеше, занимает память!)

Многократные вызовы process(obj) с тем же самым объектом в качестве аргумента ведут к тому, что результат 
вычисляется только в первый раз, а затем последующие вызовы берут его из кеша. Недостатком является то, что 
необходимо вручную очищать cache от ставших ненужными объектов.

Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут 
автоматически удалены из памяти сборщиком мусора.

// 📁 cache.js
let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются

WeakSet
Коллекция WeakSet ведёт себя похоже:

Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. 
Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может 
что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически (объект john будет удалён из visitedSet)

Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё 
содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть 
дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.

Object.keys, values, entries
В предыдущей главе мы видели методы map.keys(), map.values(), map.entries().

Это универсальные методы, и существует общее соглашение использовать их для структур данных. Если бы мы делали 
собственную структуру данных, нам также следовало бы их реализовать.

Методы поддерживаются для структур:

Map
Set
Array
Простые объекты также можно перебирать похожими методами, но синтаксис немного отличается.

Object.keys, values, entries
Для простых объектов доступны следующие методы:

Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].
Обратите внимание на различия (по сравнению с map, например):

                       Map	                Object
Синтаксис вызова	    map.keys()	     Object.keys(obj), не obj.keys()
Возвращает	       перебираемый объект	     «реальный» массив
Первое отличие в том, что мы должны вызвать Object.keys(obj), а не obj.keys().
Почему так? Основная причина – гибкость. Помните, что объекты являются основой всех сложных структур в 
JavaScript. У нас может быть объект data, который реализует свой собственный метод data.values(). И мы всё 
ещё можем применять к нему стандартный метод Object.values(data).

Второе отличие в том, что методы вида Object.* возвращают «реальные» массивы, а не просто итерируемые объекты. 
Это в основном по историческим причинам.

Например:

let user = {
  name: "John",
  age: 30
};

Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]
Вот пример использования Object.values ​​для перебора значений свойств в цикле:

let user = {
  name: "John",
  age: 30
};

// перебор значений
for (let value of Object.values(user)) {
  alert(value); // John, затем 30
}

Трансформации объекта
У объектов нет множества методов, которые есть в массивах, например map, filter и других.

Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
На нём вызываем методы массива, например, map.
Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
Это может выглядеть сложным на первый взгляд, но становится лёгким для понимания после нескольких раз 
использования.

Можно делать и более сложные «однострочные» преобразования таким путём. Важно только сохранять баланс, 
чтобы код при этом был достаточно простым для понимания.

Деструктурирующее присваивание
В JavaScript есть две чаще всего используемые структуры данных – это Object и Array.
Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам.
Массивы позволяют нам собирать элементы данных в упорядоченный список.
Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности.

Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или 
объекты в несколько переменных, так как иногда они более удобны.

Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по 
умолчанию и так далее. Скоро мы увидим это.
Деструктуризация массива
Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor

Теперь мы можем использовать переменные вместо элементов массива.

Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
alert(firstName); // Ilya
alert(surname);  // Kantor

«Деструктуризация» не означает «разрушение».
«Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания,
его задача – только скопировать нужные значения в переменные.

Это просто короткий вариант записи:

// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];

Пропускайте элементы, используя запятые
Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:

// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
В примере выше второй элемент массива пропускается, а третий присваивается переменной title, оставшиеся
элементы массива также пропускаются (так как для них нет переменных).

Работает с любым перебираемым объектом с правой стороны
…На самом деле мы можем использовать любой перебираемый объект, не только массивы:

let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);

Присваивайте чему угодно с левой стороны
Мы можем использовать что угодно «присваивающее» с левой стороны.

Например, можно присвоить свойству объекта:

let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
alert(user.surname); // Kantor

Цикл с .entries()
В предыдущей главе мы видели метод Object.entries(obj).

Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
…то же самое для map:

let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map перебирает как пары [ключ, значение], что очень удобно для деструктурирования
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
Трюк обмена переменных
Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего 
присваивания:

let guest = "Jane";
let admin = "Pete";

// Давайте поменяем местами значения: сделаем guest = "Pete", а admin = "Jane"
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (успешно заменено!)
Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.

Таким образом, мы можем поменять местами даже более двух переменных.


Остаточные параметры «…»
Обычно, если массив длиннее, чем список слева, «лишние» элементы опускаются.

Например, здесь берутся только первые два элемента, а остальные просто игнорируются:

let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// Дальнейшие элементы нигде не присваиваются
Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один 
параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2

Переменная rest является массивом из оставшихся элементов.

Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть 
три точки и она стоит на последнем месте в деструктурирующем присваивании.

let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// теперь titles = ["Consul", "of the Roman Republic"]

Значения по умолчанию
Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются 
неопределёнными:

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =:

// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)
Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, 
только если значения отсутствуют.

Например, здесь мы используем функцию prompt для указания двух значений по умолчанию.

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // результат prompt
Обратите внимание, prompt будет запущен только для пропущенного значения (surname).
Деструктуризация объекта
Деструктурирующее присваивание также работает с объектами.

Синтаксис:

let {var1, var2} = {var1:…, var2:…}
У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}.

Например:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Свойства options.title, options.width и options.height присваиваются соответствующим переменным.

Порядок не имеет значения. Вот так – тоже работает:

// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.

Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.

Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь:

let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.

В коде ниже prompt запросит width, но не title:

let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (результат prompt)
Мы также можем совмещать : и =:

let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// взять только title, игнорировать остальное
let { title } = options;

alert(title); // Menu
Остаток объекта «…»
Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?

Можно использовать троеточие, как и для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.

Выглядит так:

let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;

// сейчас title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
Обратите внимание на let
В примерах выше переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох.

Вот так не будет работать:

let title, width, height;

// ошибка будет в этой строке
{title, width, height} = {title: "Menu", width: 200, height: 100};
Проблема в том, что JavaScript обрабатывает {...} в основном потоке кода (не внутри другого выражения) как блок кода. Такие блоки кода могут быть использованы для группировки операторов, например:

{
  // блок кода
  let message = "Hello";
  // ...
  alert( message );
}
Так что здесь JavaScript считает, что видит блок кода, отсюда и ошибка. На самом-то деле у нас деструктуризация.

Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки (...):

let title, width, height;

// сейчас всё работает
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
Вложенная деструктуризация
Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.

В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:

let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
Весь объект options, кроме свойства extra, которое в левой части отсутствует, присваивается в соответствующие переменные:


В итоге у нас есть width, height, item1, item2 и title со значением по умолчанию.

Заметим, что переменные для size и items отсутствуют, так как мы взяли сразу их содержимое.

Умные параметры функций
Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов. Представьте себе функцию, которая создаёт меню. Она может иметь ширину, высоту, заголовок, список элементов и так далее.

Вот так – плохой способ писать подобные функции:

function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
В реальной жизни проблема заключается в том, как запомнить порядок всех аргументов. Обычно IDE пытаются помочь нам, особенно если код хорошо документирован, но всё же… Другая проблема заключается в том, как вызвать функцию, когда большинство параметров передавать не надо, и значения по умолчанию вполне подходят.

Разве что вот так?

// undefined там, где подходят значения по умолчанию
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
Это выглядит ужасно. И становится нечитаемым, когда мы имеем дело с большим количеством параметров.

На помощь приходит деструктуризация!

Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
Мы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием:

let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
Полный синтаксис – такой же, как для деструктурирующего присваивания:

function({
  incomingProperty: varName = defaultValue
  ...
})
Тогда для объекта с параметрами будет создана переменная varName для свойства с именем incomingProperty по умолчанию равная defaultValue.

Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:

showMenu({}); // ок, все значения - по умолчанию

showMenu(); // так была бы ошибка
Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров:

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.



Дата и время
Встречайте новый встроенный объект: Date. Он содержит дату и время, а также предоставляет методы управления ими.

Например, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

Создание
Для создания нового объекта Date нужно вызвать конструктор new Date() с одним из следующих аргументов:

new Date()
Без аргументов – создать объект Date с текущими датой и временем:

let now = new Date();
alert( now ); // показывает текущие дату и время
new Date(milliseconds)
Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

Это – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью new Date(timestamp) и преобразовать существующий объект Date в таймстамп, используя метод date.getTime() (см. ниже).

Датам до 1 января 1970 будут соответствовать отрицательные таймстампы, например:

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
new Date(datestring)
Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в Date.parse, который мы рассмотрим позже.

let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
new Date(year, month, date, hours, minutes, seconds, ms)
Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
month начинается с 0 (январь) по 11 (декабрь).
Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
Например:

new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
Максимальная точность – 1 мс (до 1/1000 секунды):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
Получение компонентов даты
Существуют методы получения года, месяца и т.д. из объекта Date:

getFullYear()
Получить год (4 цифры)
getMonth()
Получить месяц, от 0 до 11.
getDate()
Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Получить, соответственно, часы, минуты, секунды или миллисекунды.
Никакого getYear(). Только getFullYear()
Многие интерпретаторы JavaScript реализуют нестандартный и устаревший метод getYear(), который порой возвращает год в виде двух цифр. Пожалуйста, обходите его стороной. Если нужно значение года, используйте getFullYear().

Кроме того, можно получить определённый день недели:

getDay()
Вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.
Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.

Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".

Если ваш местный часовой пояс смещён относительно UTC, то следующий код покажет разные часы:

// текущая дата
let date = new Date();

// час в вашем текущем часовом поясе
alert( date.getHours() );

// час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)
alert( date.getUTCHours() );
Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

getTime()
Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

getTimezoneOffset()
Возвращает разницу в минутах между UTC и местным часовым поясом:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert( new Date().getTimezoneOffset() );
Установка компонентов даты
Следующие методы позволяют установить компоненты даты и времени:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: setHours. Если какая-то компонента не указана, она не меняется.

Пример:

let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00.
Автоисправление даты
Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

Пример:

let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!
Неправильные компоненты даты автоматически распределяются по остальным.

Предположим, нам требуется увеличить дату «28 февраля 2016» на два дня. В зависимости от того, високосный это год или нет, результатом будет «2 марта» или «1 марта». Нам об этом думать не нужно. Просто прибавляем два дня. Объект Date позаботится об остальном:

let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
Эту возможность часто используют, чтобы получить дату по прошествии заданного отрезка времени. Например, получим дату «спустя 70 секунд с текущего момента»:

let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // выводит правильную дату
Также можно установить нулевые или даже отрицательные значения. Например:

let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // задать первое число месяца
alert( date );

date.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
alert( date ); // 31 Dec 2015
Преобразование к числу, разность дат
Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime():

let date = new Date();
alert(+date); // количество миллисекунд, то же самое, что date.getTime()
Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.

Этот приём можно использовать для измерения времени:

let start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` );
Date.now()
Если нужно просто измерить время, объект Date нам не нужен.

Существует особый метод Date.now(), возвращающий текущую метку времени.

Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.

Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

Вероятно, предыдущий пример лучше переписать так:

let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты
Бенчмаркинг
Будьте внимательны, если хотите точно протестировать производительность функции, которая зависит от процессора.

Например, сравним две функции, вычисляющие разницу между двумя датами: какая сработает быстрее?

Подобные вычисления, замеряющие производительность, также называют «бенчмарками» (benchmark).

// есть date1 и date2, какая функция быстрее вернёт разницу между ними в миллисекундах?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// или
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
Обе функции делают буквально одно и то же, только одна использует явный метод date.getTime() для получения даты в миллисекундах, а другая полагается на преобразование даты в число. Результат их работы всегда один и тот же.

Но какая функция быстрее?

Для начала можно запустить их много раз подряд и засечь разницу. В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.

Проведём измерения:

function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Время diffSubtract: ' + bench(diffSubtract) + 'мс' );
alert( 'Время diffGetTime: ' + bench(diffGetTime) + 'мс' );
Вот это да! Метод getTime() работает ощутимо быстрее! Всё потому, что не производится преобразование типов, и интерпретаторам такое намного легче оптимизировать.

Замечательно, это уже что-то. Но до хорошего бенчмарка нам ещё далеко.

Представьте, что при выполнении bench(diffSubtract) процессор параллельно делал что-то ещё, также потребляющее ресурсы. А к началу выполнения bench(diffGetTime) он это уже завершил.

Достаточно реалистичный сценарий в современных многопроцессорных операционных системах.

В итоге у первого бенчмарка окажется меньше ресурсов процессора, чем у второго. Это может исказить результаты.

Для получения наиболее достоверных результатов тестирования производительности весь набор бенчмарков нужно запускать по нескольку раз.

Например, так:

function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// bench(diffSubtract) и bench(diffGetTime) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Итоговое время diffSubtract: ' + time1 );
alert( 'Итоговое время diffGetTime: ' + time2 );
Современные интерпретаторы JavaScript начинают применять продвинутые оптимизации только к «горячему коду», выполняющемуся несколько раз (незачем оптимизировать то, что редко выполняется). Так что в примере выше первые запуски не оптимизированы должным образом. Нелишним будет добавить предварительный запуск для «разогрева»:

// добавляем для "разогрева" перед основным циклом
bench(diffSubtract);
bench(diffGetTime);

// а теперь тестируем производительность
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
Будьте осторожны с микробенчмарками
Современные интерпретаторы JavaScript выполняют множество оптимизаций. Они могут повлиять на результаты «искусственных тестов» по сравнению с «нормальным использованием», особенно если мы тестируем что-то очень маленькое, например, работу оператора или встроенной функции. Поэтому если хотите серьёзно понять производительность, пожалуйста, изучите, как работают интерпретаторы JavaScript. И тогда вам, вероятно, уже не понадобятся микробенчмарки.

Отличный набор статей о V8 можно найти на https://mrale.ph.

Разбор строки с датой
Метод Date.parse(str) считывает дату из строки.

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:

YYYY-MM-DD – это дата: год-месяц-день.
Символ "T" используется в качестве разделителя.
HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.
Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN.

Например:

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)
Можно тут же создать объект new Date из таймстампа:

let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);


Введение: колбэки
В примерах мы будем использовать браузерные методы
Для демонстрации использования колбэков, промисов и других абстрактных понятий мы будем использовать некоторые браузерные методы: в частности, загрузку скриптов и выполнение простых манипуляций с документом.

Если вы не знакомы с этими методами, и их использование в примерах вызывает у вас недоумение, возможно, вам стоит прочитать несколько глав из следующей части учебника.

Тем не менее, мы все равно попытаемся максимально доходчиво всё разъяснить. Ничего особо сложного в плане браузера не будет.

Многие действия в JavaScript асинхронные.

Например, рассмотрим функцию loadScript(src):

function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
Эта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция <script src="…">, браузер загрузит скрипт и выполнит его.

Вот пример использования этой функции:

// загрузит и выполнит скрипт
loadScript('/my/script.js');
Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.

Если после вызова loadScript(…) есть какой-то код, то он не будет ждать, пока скрипт загрузится.

loadScript('/my/script.js');
// код, написанный после вызова функции loadScript,
// не будет дожидаться полной загрузки скрипта
// ...
Мы хотели бы использовать новый скрипт, как только он будет загружен. Скажем, он объявляет новую функцию, которую мы хотим выполнить.

Но если мы просто вызовем эту функцию после loadScript(…), у нас ничего не выйдет:

loadScript('/my/script.js'); // в скрипте есть "function newFunction() {…}"

newFunction(); // такой функции не существует!
Действительно, ведь у браузера не было времени загрузить скрипт. Сейчас функция loadScript никак не позволяет отследить момент загрузки. Скрипт загружается, а потом выполняется. Но нам нужно точно знать, когда это произойдёт, чтобы использовать функции и переменные из этого скрипта.

Давайте передадим функцию callback вторым аргументом в loadScript, чтобы вызвать её, когда скрипт загрузится:

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}
Событие onload описано в статье Загрузка ресурсов: onload и onerror, оно в основном выполняет функцию после загрузки и выполнения скрипта.

Теперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:

loadScript('/my/script.js', function() {
  // эта функция вызовется после того, как загрузится скрипт
  newFunction(); // теперь всё работает
  ...
});
Смысл такой: вторым аргументом передаётся функция (обычно анонимная), которая выполняется по завершении действия.

Возьмём для примера реальный скрипт с библиотекой функций:

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Здорово, скрипт ${script.src} загрузился`);
  alert( _ ); // функция, объявленная в загруженном скрипте
});
Такое написание называют асинхронным программированием с использованием колбэков. В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия.

Мы поступили похожим образом в loadScript, но это, конечно, распространённый подход.

Колбэк в колбэке
Как нам загрузить два скрипта один за другим: сначала первый, а за ним второй?

Первое, что приходит в голову, вызвать loadScript ещё раз уже внутри колбэка, вот так:

loadScript('/my/script.js', function(script) {

  alert(`Здорово, скрипт ${script.src} загрузился, загрузим ещё один`);

  loadScript('/my/script2.js', function(script) {
    alert(`Здорово, второй скрипт загрузился`);
  });

});
Когда внешняя функция loadScript выполнится, вызовется та, что внутри колбэка.

А что если нам нужно загрузить ещё один скрипт?..

loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...и так далее, пока все скрипты не будут загружены
    });

  })

});
Каждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдёт, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.

Перехват ошибок
В примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось? Колбэк должен уметь реагировать на возможные проблемы.

Ниже улучшенная версия loadScript, которая умеет отслеживать ошибки загрузки:

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));

  document.head.append(script);
}
Мы вызываем callback(null, script) в случае успешной загрузки и callback(error), если загрузить скрипт не удалось.

Живой пример:

loadScript('/my/script.js', function(error, script) {
  if (error) {
    // обрабатываем ошибку
  } else {
    // скрипт успешно загружен
  }
});
Опять же, подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).

Правила таковы:

Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.

Адская пирамида вызовов
На первый взгляд это рабочий способ написания асинхронного кода. Так и есть. Для одного или двух вложенных вызовов всё выглядит нормально.

Но для нескольких асинхронных действий, которые нужно выполнить друг за другом, код выглядит вот так:

loadScript('1.js', function(error, script) {

  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...и так далее, пока все скрипты не будут загружены (*)
          }
        });

      }
    })
  }
});
В примере выше:

Мы загружаем 1.js. Продолжаем, если нет ошибок.
Мы загружаем 2.js. Продолжаем, если нет ошибок.
Мы загружаем 3.js. Продолжаем, если нет ошибок. И так далее (*).
Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо ... у нас код, содержащий другие цепочки вызовов, условия и т.д.

Иногда это называют «адом колбэков» или «адской пирамидой колбэков».


Пирамида вложенных вызовов растёт вправо с каждым асинхронным действием. В итоге вы сами будете путаться, где что есть.

Такой подход к написанию кода не приветствуется.

Мы можем попытаться решить эту проблему, изолируя каждое действие в отдельную функцию, вот так:

loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...и так далее, пока все скрипты не будут загружены (*)
  }
};
Заметили? Этот код делает всё то же самое, но вложенность отсутствует, потому что все действия вынесены в отдельные функции.

Код абсолютно рабочий, но кажется разорванным на куски. Его трудно читать, вы наверняка заметили это. Приходится прыгать глазами между кусками кода, когда пытаешься его прочесть. Это неудобно, особенно, если читатель не знаком с кодом и не знает, что за чем следует.

Кроме того, все функции step* одноразовые, и созданы лишь только, чтобы избавиться от «адской пирамиды вызовов». Никто не будет их переиспользовать где-либо ещё. Таким образом, мы, кроме всего прочего, засоряем пространство имён.

Нужно найти способ получше.

К счастью, такие способы существуют. Один из лучших — использовать промисы, о которых рассказано в следующей главе.

Промисы
Представьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем сингле.

Чтобы получить передышку, вы обещаете разослать им сингл, когда он будет выпущен. Вы даёте фанатам список, в который они могут записаться. Они могут оставить там свой e-mail, чтобы получить песню, как только она выйдет. И даже больше: если что-то пойдёт не так, например, в студии будет пожар и песню выпустить не выйдет, они также получат уведомление об этом.

Все счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты больше не беспокоятся, что пропустят новый сингл.

Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:

Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. В нашей аналогии это – «певец».
Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
Аналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее простого списка подписок: он обладает дополнительными возможностями и ограничениями. Но для начала и такая аналогия хороша.

Синтаксис создания Promise:

let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});
Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».

Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки.
Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
Так что исполнитель по итогу переводит promise в одно из двух состояний:


Позже мы рассмотрим, как «фанаты» узнают об этих изменениях.

Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):

let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
Мы можем наблюдать две вещи, запустив код выше:

Функция-исполнитель запускается сразу же при вызове new Promise.
Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.
Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат:


Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.

А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

let promise = new Promise(function(resolve, reject) {
  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.

Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

Может быть что-то одно: либо результат, либо ошибка
Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.

Все последующие вызовы resolve и reject будут проигнорированы:

let promise = new Promise(function(resolve, reject) {
  resolve("done");

  reject(new Error("…")); // игнорируется
  setTimeout(() => resolve("…")); // игнорируется
});
Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.

Также заметим, что функция resolve/reject ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.

Вызывайте reject с объектом Error
В случае, если что-то пошло не так, мы должны вызвать reject. Это можно сделать с аргументом любого типа (как и resolve), но рекомендуется использовать объект Error (или унаследованный от него). Почему так? Скоро нам станет понятно.

Вызов resolve/reject сразу
Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть через какое-то время. Но это не обязательно, resolve или reject могут быть вызваны сразу:

let promise = new Promise(function(resolve, reject) {
  // задача, не требующая времени
  resolve(123); // мгновенно выдаст результат: 123
});
Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.

Такая ситуация нормальна. Мы сразу получим успешно завершённый Promise.

Свойства state и result – внутренние
Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally, про них речь пойдёт дальше.

Потребители: then, catch
Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.

then
Наиболее важный и фундаментальный метод – .then.

Синтаксис:

promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
Выполнилась первая функция.

А в случае ошибки в промисе – выполнится вторая:

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);
Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:

let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду
catch
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:

let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

Очистка: finally
По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.

Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

Думайте об этом как о завершении вечеринки. Независимо от того, была ли вечеринка хорошей или плохой, сколько на ней было друзей, нам все равно нужно (или, по крайней мере, мы должны) сделать уборку после нее.

Код может выглядеть следующим образом:

new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => показать результат, err => показать ошибку)
Обратите внимание, что finally(f) – это не совсем псевдоним then(f,f), как можно было подумать.

Есть важные различия:

Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.

Пожалуйста, взгляните на приведенный выше пример: как вы можете видеть, обработчик finally не имеет аргументов, а результат promise обрабатывается в следующем обработчике.

Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

Например, здесь результат проходит через finally к then:

new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .then(result => alert(result)); // <-- .then показывает "value"
Как вы можете видеть, значение возвращаемое первым промисом, передается через finally к следующему then.

Это очень удобно, потому что finally не предназначен для обработки результата промиса. Как уже было сказано, это место для проведения общей очистки, независимо от того, каков был результат.

А здесь ошибка из промиса проходит через finally к catch:

new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .catch(err => alert(err));  // <-- .catch показывает ошибку
Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.

Единственным исключением из этого правила является случай, когда обработчик finally выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.

Подведем итог:

Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
Если обработчик finally возвращает что-то, это игнорируется.
Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.
Эти функции полезны и заставляют все работать правильно, если мы используем finally так, как предполагается: для общих процедур очистки.

На завершённых промисах обработчики запускаются сразу
Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его.

Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.

В таком случае эти обработчики просто запускаются немедленно:

// при создании промиса он сразу переводится в состояние "успешно завершён"
let promise = new Promise(resolve => resolve("готово!"));

promise.then(alert); // готово! (выведется сразу)
Пример: loadScript
Теперь рассмотрим несколько практических примеров того, как промисы могут облегчить нам написание асинхронного кода.

У нас есть функция loadScript для загрузки скрипта из предыдущей главы.

Давайте вспомним, как выглядел вариант с колбэками:

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}
Теперь перепишем её, используя Promise.

Новой функции loadScript более не нужен аргумент callback. Вместо этого она будет создавать и возвращать объект Promise, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя .then:

function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
  });
}
Применение:

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} загружен!`),
  error => alert(`Ошибка: ${error.message}`)
);

promise.then(script => alert('Ещё один обработчик...'));
Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

Промисы	Колбэки
Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем loadScript(script), и затем (.then) мы пишем, что делать с результатом.	У нас должна быть функцияcallback на момент вызова loadScript(script, callback). Другими словами, нам нужно знать что делать с результатом до того, как вызовется loadScript.
Мы можем вызывать .then у Promise столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующей главе: Цепочка промисов.	Колбэк может быть только один.
Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это далеко не всё. Мы узнаем ещё много полезного в последующих главах.

Цепочка промисов
Давайте вернёмся к ситуации из главы Введение: колбэки: у нас есть последовательность асинхронных задач, которые должны быть выполнены одна за другой. Например, речь может идти о загрузке скриптов. Как же грамотно реализовать это в коде?

Промисы предоставляют несколько способов решения подобной задачи.

В этой главе мы разберём цепочку промисов.

Она выглядит вот так:

new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

Поток выполнения такой:

Начальный промис успешно выполняется через 1 секунду (*),
Затем вызывается обработчик в .then (**).
Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
…и так далее.
В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.


Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.

Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий .then.

Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.

Например:

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});
Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют независимо.

Вот картина происходящего (сравните это с изображением цепочки промисов выше):


Все обработчики .then на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса. Таким образом, в коде выше все alert показывают одно и то же: 1.

На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда чаще.

Возвращаем промисы
Обработчик handler, переданный в .then(handler), может вернуть промис.

В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.

Например:

new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1

  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) { // (**)

  alert(result); // 2

  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 4

});
Здесь первый .then показывает 1 и возвращает новый промис new Promise(…) в строке (*). Через одну секунду этот промис успешно выполняется, и его результат (аргумент в resolve, то есть result * 2) передаётся обработчику в следующем .then. Он находится в строке (**), показывает2 и делает то же самое.

Таким образом, как и в предыдущем примере, выводятся 1 → 2 → 4, но сейчас между вызовами alert существует пауза в 1 секунду.

Возвращая промисы, мы можем строить цепочки из асинхронных действий.

Пример: loadScript
Давайте используем эту возможность вместе с промисифицированной функцией loadScript, созданной нами в предыдущей главе, чтобы загружать скрипты по очереди, последовательно:

loadScript("/article/promise-chaining/one.js")
  .then(function(script) {
    return loadScript("/article/promise-chaining/two.js");
  })
  .then(function(script) {
    return loadScript("/article/promise-chaining/three.js");
  })
  .then(function(script) {
    // вызовем функции, объявленные в загружаемых скриптах,
    // чтобы показать, что они действительно загрузились
    one();
    two();
    three();
  });
Этот же код можно переписать немного компактнее, используя стрелочные функции:

loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    // скрипты загружены, мы можем использовать объявленные в них функции
    one();
    two();
    three();
  });
Здесь каждый вызов loadScript возвращает промис, и следующий обработчик в .then срабатывает, только когда этот промис завершается. Затем инициируется загрузка следующего скрипта и так далее. Таким образом, скрипты загружаются один за другим.

Мы можем добавить и другие асинхронные действия в цепочку. Обратите внимание, что наш код всё ещё «плоский», он «растёт» вниз, а не вправо. Нет никаких признаков «адской пирамиды вызовов».

Технически мы бы могли добавлять .then напрямую к каждому вызову loadScript, вот так:

loadScript("/article/promise-chaining/one.js").then(script1 => {
  loadScript("/article/promise-chaining/two.js").then(script2 => {
    loadScript("/article/promise-chaining/three.js").then(script3 => {
      // эта функция имеет доступ к переменным script1, script2 и script3
      one();
      two();
      three();
    });
  });
});
Этот код делает то же самое: последовательно загружает 3 скрипта. Но он «растёт вправо», так что возникает такая же проблема, как и с колбэками.

Разработчики, которые не так давно начали использовать промисы, иногда не знают про цепочки и пишут код именно так, как показано выше. В целом, использование цепочек промисов предпочтительнее.

Иногда всё же приемлемо добавлять .then напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости. В примере выше самая глубоко вложенная функция обратного вызова имеет доступ ко всем переменным script1, script2, script3. Но это скорее исключение, чем правило.

Thenable
Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты называют «thenable», и этот объект будет обработан как промис.

Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут иметь свои наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод .then.

Вот пример такого объекта:

class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // будет успешно выполнено с аргументом this.num*2 через 1 секунду
    setTimeout(() => resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve => resolve(1))
  .then(result => {
    return new Thenable(result); // (*)
  })
  .then(alert); // показывает 2 через 1000мс
JavaScript проверяет объект, возвращаемый из обработчика .then в строке (*): если у него имеется метод then, который можно вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции resolve и reject, вызов одной из которых потом ожидается. В примере выше происходит вызов resolve(2) через 1 секунду (**). Затем результат передаётся дальше по цепочке.

Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.

Более сложный пример: fetch
Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.

Мы будем использовать метод fetch, чтобы подгрузить информацию о пользователях с удалённого сервера. Этот метод имеет много опциональных параметров, разобранных в соответствующих разделах, но базовый синтаксис весьма прост:

let promise = fetch(url);
Этот код запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект response после того, как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.

Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется, когда данные полностью загружены с удалённого сервера, и возвращает эти данные.

Код ниже запрашивает файл user.json и загружает его содержимое с сервера:

fetch('/article/promise-chaining/user.json')
  // .then в коде ниже выполняется, когда удалённый сервер отвечает
  .then(function(response) {
    // response.text() возвращает новый промис,
    // который выполняется и возвращает полный ответ сервера,
    // когда он загрузится
    return response.text();
  })
  .then(function(text) {
    // ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
  });
Есть также метод response.json(), который читает данные в формате JSON. Он больше подходит для нашего примера, так что давайте использовать его.

Мы также применим стрелочные функции для более компактной записи кода:

// то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя
Теперь давайте что-нибудь сделаем с полученными данными о пользователе.

Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя и показать его аватар:

// Запрашиваем user.json
fetch('/article/promise-chaining/user.json')
  // Загружаем данные в формате json
  .then(response => response.json())
  // Делаем запрос к GitHub
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  // Загружаем ответ в формате json
  .then(response => response.json())
  // Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
  .then(githubUser => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => img.remove(), 3000); // (*)
  });
Код работает, детали реализации отражены в комментариях. Однако в нём есть одна потенциальная проблема, с которой часто сталкиваются новички.

Посмотрите на строку (*): как мы можем предпринять какие-то действия после того, как аватар был показан и удалён? Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё. Сейчас это невозможно.

Чтобы сделать наш код расширяемым, нам нужно возвращать ещё один промис, который выполняется после того, как завершается показ аватара.

Примерно так:

fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise(function(resolve, reject) { // (*)
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser); // (**)
    }, 3000);
  }))
  // срабатывает через 3 секунды
  .then(githubUser => alert(`Закончили показ ${githubUser.name}`));
То есть, обработчик .then в строке (*) будет возвращать new Promise, который перейдёт в состояние «выполнен» только после того, как в setTimeout (**) будет вызвана resolve(githubUser).

Соответственно, следующий по цепочке .then будет ждать этого.

Как правило, все асинхронные действия должны возвращать промис.

Это позволяет планировать после него какие-то дополнительные действия. Даже если эта возможность не нужна прямо сейчас, она может понадобиться в будущем.

И, наконец, давайте разобьём написанный код на отдельные функции, пригодные для повторного использования:

function loadJson(url) {
  return fetch(url)
    .then(response => response.json());
}

function loadGithubUser(name) {
  return fetch(`https://api.github.com/users/${name}`)
    .then(response => response.json());
}

function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}

// Используем их:
loadJson('/article/promise-chaining/user.json')
  .then(user => loadGithubUser(user.name))
  .then(showAvatar)
  .then(githubUser => alert(`Показ аватара ${githubUser.name} завершён`));
  // ...
Итого
Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.
Промисы: обработка ошибок
Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.

Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует), и .catch перехватывает ошибку:

fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
Как видно, .catch не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких .then

Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:

fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));
Если все в порядке, то такой .catch вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.

Неявный try…catch
Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:

new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(alert); // Error: Ошибка!
…Работает так же, как и этот:

new Promise((resolve, reject) => {
  reject(new Error("Ошибка!"));
}).catch(alert); // Error: Ошибка!
"Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (throw) из обработчика (.then), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:

new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  throw new Error("Ошибка!"); // генерируем ошибку
}).catch(alert); // Error: Ошибка!
Это происходит для всех ошибок, не только для тех, которые вызваны оператором throw. Например, программная ошибка:

new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  blabla(); // нет такой функции
}).catch(alert); // ReferenceError: blabla is not defined
Финальный .catch перехватывает как промисы, в которых вызван reject, так и случайные ошибки в обработчиках.

Пробрасывание ошибок
Как мы уже заметили, .catch ведёт себя как try..catch. Мы можем иметь столько обработчиков .then, сколько мы хотим, и затем использовать один .catch в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном try..catch мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then.

В примере ниже .catch успешно обрабатывает ошибку:

// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Управление перейдёт в следующий then"));
Здесь блок .catch завершается нормально. Поэтому вызывается следующий успешный обработчик .then.

В примере ниже мы видим другую ситуацию с блоком .catch. Обработчик (*) перехватывает ошибку и не может обработать её (например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:

// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

    throw error; // пробрасывает эту или другую ошибку в следующий catch
  }

}).then(function() {
  /* не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
Управление переходит от первого блока .catch (*) к следующему (**), вниз по цепочке.

Необработанные ошибки
Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить .catch в конец цепочки, как здесь:

new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // обработчики .then, один или более
  }); // без .catch в самом конце!
В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.

Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.

JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:

window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
Это событие является частью стандарта HTML.

Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, и соответствующий объект event содержит информацию об ошибке.

Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.

Итого
.catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.
.then также перехватывает ошибки таким же образом, если задан второй аргумент (который является обработчиком ошибок).
Необходимо размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).
Можно и совсем не использовать .catch, если нет нормального способа восстановиться после ошибки.
В любом случае нам следует использовать обработчик события unhandledrejection (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».

Promise API
В классе Promise есть 6 статических методов. Давайте познакомимся с ними.

Promise.all
Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

Для этого как раз и пригодится Promise.all.

Синтаксис:

let promise = Promise.all(iterable);
Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.

Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:

Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.

Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернуть получившийся массив в Promise.all.

Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));

// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
А вот пример побольше, с получением информации о пользователях GitHub по их логинам из массива (мы могли бы получать массив товаров по их идентификаторам, логика та же):

let names = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {
    // все промисы успешно завершены
    for(let response of responses) {
      alert(`${response.url}: ${response.status}`); // покажет 200 для каждой ссылки
    }

    return responses;
  })
  // преобразовать массив ответов response в response.json(),
  // чтобы прочитать содержимое каждого
  .then(responses => Promise.all(responses.map(r => r.json())))
  // все JSON-ответы обработаны, users - массив с результатами
  .then(users => users.forEach(user => alert(user.name)));
Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.

Например:

Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Ошибка!
Здесь второй промис завершится с ошибкой через 2 секунды. Это приведёт к немедленной ошибке в Promise.all, так что выполнится .catch: ошибка этого промиса становится ошибкой всего Promise.all.

В случае ошибки, остальные результаты игнорируются
Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.

Например, если сделано несколько вызовов fetch, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но Promise.all за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

Promise.all ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». В главе Fetch: прерывание запроса мы рассмотрим AbortController, который помогает с этим, но он не является частью Promise API.

Promise.all(iterable) разрешает передавать не-промисы в iterable (перебираемом объекте)
Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».

Например, здесь результат: [1, 2, 3]

Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2,
  3
]).then(alert); // 1, 2, 3
Таким образом, мы можем передавать уже готовые значения, которые не являются промисами, в Promise.all, иногда это бывает удобно.

Promise.allSettled
Новая возможность
Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.
Синтаксис:

let promise = Promise.allSettled(iterable);
Promise.all завершается с ошибкой, если она возникает в любом из переданных промисов. Это подходит для ситуаций «всё или ничего», когда нам нужны все результаты для продолжения:

Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')
]).then(render); // методу render нужны результаты всех fetch
Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет

{status:"fulfilled", value:результат} для успешных завершений,
{status:"rejected", reason:ошибка} для ошибок.
Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.

Используем для этого Promise.allSettled:

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
Массив results в строке (*) будет таким:

[
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'rejected', reason: ...объект ошибки...}
]
То есть, для каждого промиса у нас есть его статус и значение/ошибка.

Полифил
Если браузер не поддерживает Promise.allSettled, для него легко сделать полифил:

if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      status: 'fulfilled',
      value: value
    }), error => ({
      status: 'rejected',
      reason: error
    }))));
  };
}
В этом коде promises.map берёт аргументы, превращает их в промисы (на всякий случай) и добавляет каждому обработчик .then.

Этот обработчик превращает успешный результат value в {state:'fulfilled', value: value}, а ошибку error в {state:'rejected', reason: error}. Это как раз и есть формат результатов Promise.allSettled.

Затем мы можем использовать Promise.allSettled, чтобы получить результаты всех промисов, даже если при выполнении какого-то возникнет ошибка.

Promise.race
Метод очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).

Синтаксис:

let promise = Promise.race(iterable);
Например, тут результат будет 1:

Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
Быстрее всех выполнился первый промис, он и дал результат. После этого остальные промисы игнорируются.

Promise.any
Метод очень похож на Promise.race, но ждёт только первый успешно выполненный промис, из которого берёт результат.

Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.

Синтаксис:

let promise = Promise.any(iterable);
Например, здесь, результатом будет 1:

Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
Первый промис в этом примере был самым быстрым, но он был отклонён, поэтому результатом стал второй. После того, как первый успешно выполненный промис «выиграет гонку», все дальнейшие результаты будут проигнорированы.

Вот пример, в котором все промисы отклоняются:

Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ещё одна ошибка!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // AggregateError
  console.log(error.errors[0]); // Error: Ошибка!
  console.log(error.errors[1]); // Error: Ещё одна ошибка!
});
Как вы можете видеть, объекты ошибок для отклонённых промисов доступны в свойстве errors объекта AggregateError.

Promise.resolve/reject
Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы рассмотрим его чуть позже) делает их, в общем-то, не нужными.

Мы рассмотрим их здесь для полноты картины, а также для тех, кто по каким-то причинам не может использовать async/await.

Promise.resolve
Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
То же самое, что:

let promise = new Promise(resolve => resolve(value));
Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.

Например, функция loadCached ниже загружает URL и запоминает (кеширует) его содержимое. При будущих вызовах с тем же URL он тут же читает предыдущее содержимое из кеша, но использует Promise.resolve, чтобы сделать из него промис, для того, чтобы возвращаемое значение всегда было промисом:

let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
    return Promise.resolve(cache.get(url)); // (*)
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
Мы можем писать loadCached(url).then(…), потому что функция loadCached всегда возвращает промис. Мы всегда можем использовать .then после loadCached. Это и есть цель использования Promise.resolve в строке (*).

Promise.reject
Promise.reject(error) создаёт промис, завершённый с ошибкой error.
То же самое, что:

let promise = new Promise((resolve, reject) => reject(error));
На практике этот метод почти никогда не используется.

Итого
Мы ознакомились с шестью статическими методами класса Promise:

Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
Promise.allSettled(promises) (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
status: "fulfilled", если выполнен успешно или "rejected", если ошибка,
value – результат, если успешно или reason – ошибка, если нет.
Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
Promise.any(promises) (добавлен недавно) – ожидает первый успешно выполненный промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, AggregateError становится ошибкой Promise.any.
Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
Promise.reject(error) – возвращает промис с ошибкой error.
Из всех перечисленных методов, самый часто используемый – это, пожалуй, Promise.all.

Промисификация
Промисификация – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.

Такие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл «промисифицировать» их.

Например, у нас есть loadScript(src, callback) из главы Введение: колбэки.

function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// использование:
// loadScript('path/script.js', (err, script) => {...})
Давайте промисифицируем её. Новая функция loadScriptPromise(src) будет делать то же самое, но будет принимать только src (не callback) и возвращать промис.

let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// использование:
// loadScriptPromise('path/script.js').then(...)
Теперь loadScriptPromise хорошо вписывается в код, основанный на промисах.

Как видно, она передаёт всю работу исходной функции loadScript, предоставляя ей колбэк, по вызову которого происходит resolve/reject промиса.

На практике нам, скорее всего, понадобится промисифицировать не одну функцию, поэтому имеет смысл сделать для этого специальную «функцию-помощник».

Мы назовём её promisify(f) – она принимает функцию для промисификации f и возвращает функцию-обёртку.

Эта функция-обёртка делает то же самое, что и код выше: возвращает промис и передаёт вызов оригинальной f, отслеживая результат в своём колбэке:

function promisify(f) {
  return function (...args) { // возвращает функцию-обёртку
    return new Promise((resolve, reject) => {
      function callback(err, result) { // наш специальный колбэк для f
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback); // добавляем колбэк в конец аргументов f

      f.call(this, ...args); // вызываем оригинальную функцию
    });
  };
};

// использование:
let loadScriptPromise = promisify(loadScript);
loadScriptPromise(...).then(...);
Здесь мы предполагаем, что исходная функция ожидает колбэк с двумя аргументами (err, result). Это то, с чем мы чаще всего сталкиваемся. Тогда наш колбэк – в правильном формате, и promisify отлично работает для такого случая.

Но что, если исходная f ожидает колбэк с большим количеством аргументов callback(err, res1, res2, ...)?

Ниже описана улучшенная функция promisify: при вызове promisify(f, true) результатом промиса будет массив результатов [res1, res2, ...]:

// promisify(f, true), чтобы получить массив результатов
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // наш специальный колбэк для f
        if (err) {
          reject(err);
        } else {
          // делаем resolve для всех results колбэка, если задано manyArgs
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// использование:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...)
Для более экзотических форматов колбэка, например без err: callback(result), мы можем промисифицировать функции без помощника, «вручную».

Также существуют модули с более гибкой промисификацией, например, es6-promisify или встроенная функция util.promisify в Node.js.

На заметку:
Промисификация – это отличный подход, особенно, если вы будете использовать async/await (см. следующую главу), но она не является тотальной заменой любых колбэков.

Помните, промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.

Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.


Микрозадачи
Обработчики промисов .then/.catch/.finally всегда асинхронны.

Даже когда промис сразу же выполнен, код в строках ниже .then/.catch/.finally будет запущен до этих обработчиков.

Вот демо:

let promise = Promise.resolve();

promise.then(() => alert("промис выполнен"));

alert("код выполнен"); // этот alert показывается первым
Если вы запустите его, сначала вы увидите код выполнен, а потом промис выполнен.

Это странно, потому что промис определённо был выполнен с самого начала.

Почему .then срабатывает позже? Что происходит?

Очередь микрозадач
Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» (термин V8).

Как сказано в спецификации:

Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
Выполнение задачи происходит только в том случае, если ничего больше не запущено.
Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.


Обработчики промисов всегда проходят через эту внутреннюю очередь.

Если есть цепочка с несколькими .then/catch/finally, то каждый из них выполняется асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.

Но что если порядок имеет значение для нас? Как мы можем вывести код выполнен после промис выполнен?

Легко, используя .then:

Promise.resolve()
  .then(() => alert("промис выполнен!"))
  .then(() => alert("код выполнен"));
Теперь порядок стал таким, как было задумано.

Необработанные ошибки
Помните «необработанные ошибки» из главы Промисы: обработка ошибок?

Теперь мы можем описать, как именно JavaScript понимает, что ошибка не обработана.

"Необработанная ошибка" возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.

Обычно, если мы ожидаем ошибку, мы добавляем .catch в конец цепочки промисов, чтобы обработать её:

let promise = Promise.reject(new Error("Ошибка в промисе!"));
promise.catch(err => alert('поймана!'));

// не запустится, ошибка обработана
window.addEventListener('unhandledrejection', event => {
  alert(event.reason);
});
…Но если мы забудем добавить .catch, то, когда очередь микрозадач опустеет, движок сгенерирует событие:

let promise = Promise.reject(new Error("Ошибка в промисе!"));

// Ошибка в промисе!
window.addEventListener('unhandledrejection', event => alert(event.reason));
А что, если мы поймаем ошибку, но позже? Вот так:

let promise = Promise.reject(new Error("Ошибка в промисе!"));

setTimeout(() => promise.catch(err => alert('поймана')), 1000);

// Ошибка в промисе!
window.addEventListener('unhandledrejection', event => alert(event.reason));
Теперь, при запуске, мы сначала увидим «Ошибка в промисе!», а затем «поймана».

Если бы мы не знали про очередь микрозадач, то могли бы удивиться: «Почему сработал обработчик unhandledrejection? Мы же поймали ошибку!».

Но теперь мы понимаем, что событие unhandledrejection возникает, когда очередь микрозадач завершена: движок проверяет все промисы и, если какой-либо из них в состоянии «rejected», то генерируется это событие.

В примере выше .catch, добавленный в setTimeout, также срабатывает, но позже, уже после возникновения unhandledrejection, так что это ни на что не влияет.

Итого
Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин v8).

Таким образом, обработчики .then/catch/finally вызываются после выполнения текущего кода.

Если нам нужно гарантировать выполнение какого-то кода после .then/catch/finally, то лучше всего добавить его вызов в цепочку .then.

В большинстве движков JavaScript, включая браузеры и Node.js, микрозадачи тесно связаны с так называемым «событийным циклом» и «макрозадачами». Так как они не связаны напрямую с промисами, то рассматриваются в другой части учебника, в главе Событийный цикл: микрозадачи и макрозадачи.